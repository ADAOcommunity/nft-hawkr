{"version":3,"file":"57352d49-2430e83b7272a844bdcd.js","mappings":"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","sources":["webpack://yoctodao-interface/./node_modules/@egjs/infinitegrid/dist/infinitegrid.esm.js"],"sourcesContent":["/*\nCopyright (c) 2015 NAVER Corp.\nname: @egjs/infinitegrid\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-infinitegrid\nversion: 3.9.0\n*/\nimport Component from '@egjs/component';\nimport { diff } from '@egjs/list-differ';\nimport ImReady from '@egjs/imready';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}\n\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {\n    document: {},\n    navigator: {\n      userAgent: \"\"\n    }\n  };\n} else {\n  win = window;\n}\n\nvar document = win.document;\n\nvar _a;\n\nvar ua = win.navigator.userAgent;\nvar SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in win);\nvar SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\n\nvar SUPPORT_PASSIVE = function () {\n  var supportsPassiveOption = false;\n\n  try {\n    if (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n      // tslint:disable-next-line: no-empty\n      document.addEventListener(\"test\", function () {}, Object.defineProperty({}, \"passive\", {\n        get: function get() {\n          supportsPassiveOption = true;\n        }\n      }));\n    }\n  } catch (e) {//\n  }\n\n  return supportsPassiveOption;\n}();\n\nvar IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nvar IS_IOS = /iPhone|iPad/.test(ua);\nvar IS_ANDROID2 = /Android 2\\./.test(ua);\nvar CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nvar IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\nvar TRANSITION_NAME = \"_INFINITEGRID_TRANSITION\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar DUMMY_POSITION = -100000;\nvar GROUPKEY_ATT = \"data-groupkey\";\nvar DEFAULT_OPTIONS = {\n  itemSelector: \"*\",\n  isOverflowScroll: false,\n  threshold: 100,\n  isEqualSize: false,\n  isConstantSize: false,\n  useRecycle: true,\n  horizontal: false,\n  transitionDuration: 0,\n  useFit: true,\n  attributePrefix: \"data-\",\n  renderExternal: false,\n  resizeDebounce: 100,\n  maxResizeDebounce: 0,\n  percentage: false,\n  useOffset: false\n};\nvar DEFAULT_LAYOUT_OPTIONS = {\n  horizontal: false,\n  margin: 0\n};\nvar agent = ua.toLowerCase();\nvar isMobile = /mobi|ios|android/.test(agent);\nvar ALIGN = {\n  START: \"start\",\n  CENTER: \"center\",\n  END: \"end\",\n  JUSTIFY: \"justify\"\n};\nvar IDLE = 0;\nvar LOADING_APPEND = 1;\nvar LOADING_PREPEND = 2;\nvar PROCESSING = 4;\nvar webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\nvar WEBKIT_VERSION = webkit && parseInt(webkit[1], 10) || 0;\nvar DEFENSE_BROWSER = WEBKIT_VERSION && WEBKIT_VERSION < 537;\nvar ITEM_KEYS = [\"content\", \"groupKey\", \"itemKey\", \"orgSize\", \"mounted\", \"prevRect\", \"rect\", \"size\"];\nvar TRANSFORM = (_a = function () {\n  var properties = {\n    transitionend: \"\",\n    webkitTransitionEnd: \"-webkit-\",\n    MSTransitionEnd: \"-ms-\",\n    oTransitionEnd: \"-o-\",\n    mozTransitionEnd: \"-moz-\"\n  };\n\n  for (var property in properties) {\n    var prefix = properties[property];\n\n    if (\"on\" + property.toLowerCase() in win) {\n      return [prefix + \"transform\", prefix + \"transition\", property];\n    }\n  }\n\n  return [];\n}(), _a[0]),\n    TRANSITION = _a[1],\n    TRANSITION_END = _a[2];\nvar INFINITEGRID_EVENTS = [\"append\", \"prepend\", \"imageError\", \"change\", \"layoutComplete\"]; // It's for making mistakes.\n// Whenever you add a public method, you must add the corresponding method name to an array or object.\n// An additional error may occur if not added.\n\nvar INFINITEGRID_METHODS = {\n  getLoadingBar: true,\n  getItem: true,\n  getItems: true,\n  layout: true,\n  getGroupKeys: true,\n  getStatus: true,\n  setStatus: true,\n  isProcessing: true,\n  startLoading: true,\n  endLoading: true,\n  isLoading: true,\n  updateItem: true,\n  updateItems: true,\n  moveTo: true\n};\n\nfunction toArray(nodes) {\n  // SCRIPT5014 in IE8\n  var array = [];\n\n  if (nodes) {\n    var length = nodes.length;\n\n    for (var i = 0; i < length; i++) {\n      array.push(nodes[i]);\n    }\n  }\n\n  return array;\n}\n\nfunction matchHTML(html) {\n  return html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n\nfunction $(param, multi) {\n  if (multi === void 0) {\n    multi = false;\n  }\n\n  var el;\n\n  if (typeof param === \"string\") {\n    // String (HTML, Selector)\n    // check if string is HTML tag format\n    var match = matchHTML(param); // creating element\n\n    if (match) {\n      // HTML\n      var dummy = document.createElement(\"div\");\n      dummy.innerHTML = param;\n      el = dummy.childNodes;\n    } else {\n      // Selector\n      el = document.querySelectorAll(param);\n    }\n\n    if (multi) {\n      return toArray(el);\n    } else {\n      return el && el[0];\n    }\n  } else if (isWindow(param)) {\n    // window\n    el = param;\n  } else if (isJQuery(param)) {\n    // jQuery\n    el = multi ? $(param.toArray(), true) : $(param.get(0), false);\n  } else if (Array.isArray(param)) {\n    el = param.map(function (v) {\n      return $(v);\n    });\n\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n    // HTMLElement, Document\n    el = param;\n  } else {\n    el = [].slice.call(el);\n  }\n\n  return el;\n}\n\nfunction addEvent(element, type, handler, eventListenerOptions) {\n  if (SUPPORT_ADDEVENTLISTENER) {\n    var options = eventListenerOptions || false;\n\n    if (typeof eventListenerOptions === \"object\") {\n      options = SUPPORT_PASSIVE ? eventListenerOptions : false;\n    }\n\n    element.addEventListener(type, handler, options);\n  } else if (element.attachEvent) {\n    element.attachEvent(\"on\" + type, handler);\n  } else {\n    element[\"on\" + type] = handler;\n  }\n}\n\nfunction removeEvent(element, type, handler) {\n  if (element.removeEventListener) {\n    element.removeEventListener(type, handler, false);\n  } else if (element.detachEvent) {\n    element.detachEvent(\"on\" + type, handler);\n  } else {\n    element[\"on\" + type] = null;\n  }\n}\n\nfunction addOnceEvent(element, type, handler, eventListenerOptions) {\n  var callback = function callback(e) {\n    removeEvent(element, type, callback);\n    handler(e);\n  };\n\n  addEvent(element, type, callback, eventListenerOptions);\n}\n\nfunction scroll(el, horizontal) {\n  if (horizontal === void 0) {\n    horizontal = false;\n  }\n\n  var prop = \"scroll\" + (horizontal ? \"Left\" : \"Top\");\n\n  if (isWindow(el)) {\n    return win[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || document.body[prop] || document.documentElement[prop];\n  } else {\n    return el[prop];\n  }\n}\n\nfunction scrollTo(el, x, y) {\n  if (isWindow(el)) {\n    el.scroll(x, y);\n  } else {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n}\n\nfunction scrollBy(el, x, y) {\n  if (isWindow(el)) {\n    el.scrollBy(x, y);\n  } else {\n    el.scrollLeft += x;\n    el.scrollTop += y;\n  }\n}\n\nfunction getStyle(el) {\n  return (SUPPORT_COMPUTEDSTYLE ? win.getComputedStyle(el) : el.currentStyle) || {};\n}\n\nfunction getSize(el, name, type) {\n  if (isWindow(el)) {\n    // WINDOW\n    return win[\"inner\" + name] || document.body[\"client\" + name];\n  } else if (isDocument(el)) {\n    // DOCUMENT_NODE\n    var doc = el.documentElement;\n    var body = el.body;\n    return Math.max(body[\"scroll\" + name], doc[\"scroll\" + name], body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n  } else {\n    // NODE\n    var size = 0;\n\n    if (type === \"rect\") {\n      var clientRect = el.getBoundingClientRect();\n      size = name === \"Width\" ? clientRect.right - clientRect.left : clientRect.bottom - clientRect.top;\n    } else if (type === \"offset\") {\n      size = el[\"offset\" + name] || el[\"client\" + name];\n    } else {\n      size = el[\"client\" + name] || el[\"offset\" + name];\n    }\n\n    if (size) {\n      return size;\n    }\n\n    var cssSize = getStyle(el)[name.toLowerCase()];\n    return ~cssSize.indexOf(\"px\") && parseFloat(cssSize) || 0;\n  }\n}\n\nfunction getClientWidth(el) {\n  return getSize(el, \"Width\", \"client\");\n}\n\nfunction getClientHeight(el) {\n  return getSize(el, \"Height\", \"client\");\n}\n\nfunction getOffsetWidth(el) {\n  return getSize(el, \"Width\", \"offset\");\n}\n\nfunction getOffsetHeight(el) {\n  return getSize(el, \"Height\", \"offset\");\n}\n\nfunction getRectWidth(el) {\n  return getSize(el, \"Width\", \"rect\");\n}\n\nfunction getRectHeight(el) {\n  return getSize(el, \"Height\", \"rect\");\n}\n\nfunction getOffsetSize(el) {\n  return {\n    width: getOffsetWidth(el),\n    height: getOffsetHeight(el)\n  };\n}\n\nfunction getRectSize(el) {\n  return {\n    width: getRectWidth(el),\n    height: getRectHeight(el)\n  };\n}\n\nvar STYLE = {\n  vertical: {\n    startPos1: \"top\",\n    endPos1: \"bottom\",\n    size1: \"height\",\n    startPos2: \"left\",\n    endPos2: \"right\",\n    size2: \"width\"\n  },\n  horizontal: {\n    startPos1: \"left\",\n    endPos1: \"right\",\n    size1: \"width\",\n    startPos2: \"top\",\n    endPos2: \"bottom\",\n    size2: \"height\"\n  }\n};\n\nfunction getStyleNames(isHorizontal) {\n  return STYLE[isHorizontal ? HORIZONTAL : VERTICAL];\n}\n\nfunction assign(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  sources.forEach(function (source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\n\nfunction assignOptions(defaultOptions, options) {\n  return assign({}, DEFAULT_LAYOUT_OPTIONS, defaultOptions, options);\n}\n\nfunction toZeroArray(outline) {\n  if (!outline || !outline.length) {\n    return [0];\n  }\n\n  return outline;\n}\n\nfunction cloneItems(items) {\n  return items.map(function (item) {\n    return assign({}, item);\n  });\n}\n\nfunction isJQuery(el) {\n  return typeof win.jQuery === \"function\" && el instanceof win.jQuery || el.constructor.prototype.jquery && el.toArray;\n}\n\nfunction isWindow(el) {\n  return el === win;\n}\n\nfunction isDocument(el) {\n  return el.nodeType === 9;\n}\n\nfunction fill(arr, value) {\n  var length = arr.length;\n\n  for (var i = length - 1; i >= 0; --i) {\n    arr[i] = value;\n  }\n\n  return arr;\n}\n\nfunction isUndefined(target) {\n  return typeof target === \"undefined\";\n}\n\nfunction find(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nfunction findLast(arr, callback) {\n  var length = arr.length;\n\n  for (var i = length - 1; i >= 0; --i) {\n    if (callback(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nfunction categorize(newItems) {\n  var newGroups = [];\n  var groupKeys = {};\n  newItems.forEach(function (item) {\n    var groupKey = item.groupKey;\n    var group = groupKeys[groupKey];\n\n    if (!group) {\n      group = {\n        groupKey: groupKey,\n        items: []\n      };\n      groupKeys[groupKey] = group;\n      newGroups.push(group);\n    }\n\n    group.items.push(item);\n  });\n  return newGroups;\n}\n\nfunction resetSize(item) {\n  item.orgSize = null;\n  item.size = null;\n}\n\nfunction makeItem(groupKey, el) {\n  return {\n    el: el,\n    groupKey: groupKey,\n    mounted: false,\n    needUpdate: true,\n    content: el ? el.outerHTML : \"\",\n    rect: {\n      top: DUMMY_POSITION,\n      left: DUMMY_POSITION\n    }\n  };\n}\n/**\n * Decorator that makes the method of infinitegrid available in the framework.\n * @ko        .\n * @memberof eg.InfiniteGrid\n * @private\n * @example\n * ```js\n * import NativeInfiniteGrid, { withInfiniteGridMethods } from \"@egjs/infinitegrid\";\n *\n * class InfiniteGrid extends React.Component<Partial<InfiniteGridProps & InfiniteGridOptions>> {\n *   &#64;withInfiniteGridMethods\n *   private infinitegrid: NativeInfiniteGrid;\n * }\n * ```\n */\n\n\nfunction withInfiniteGridMethods(prototype, infinitegridName) {\n  Object.keys(INFINITEGRID_METHODS).forEach(function (name) {\n    if (prototype[name]) {\n      return;\n    }\n\n    prototype[name] = function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = (_a = this[infinitegridName])[name].apply(_a, args); // fix `this` type to return your own `infinitegrid` instance to the instance using the decorator.\n\n\n      if (result === this[infinitegridName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n\nfunction hasClass(element, className) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n\n  return !!element.className.match(new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\"));\n}\n\nfunction addClass(element, className) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += \" \" + className;\n  }\n}\n\nfunction isObject(value) {\n  return typeof value === \"object\";\n}\n\nfunction getRangeCost(value, range) {\n  return Math.max(value - range[1], range[0] - value, 0) + 1;\n}\n\nvar ItemManager = /*#__PURE__*/function () {\n  function ItemManager() {\n    // groups\n    this._groups = []; // group keys\n\n    this._groupKeys = {};\n  }\n\n  var __proto = ItemManager.prototype;\n\n  ItemManager.toItems = function (elements, groupKey) {\n    return elements.map(function (el) {\n      return makeItem(groupKey, el);\n    });\n  };\n\n  ItemManager.pluck = function (data, property) {\n    return data.reduce(function (acc, v) {\n      return acc.concat(v[property]);\n    }, []);\n  };\n\n  __proto.clear = function () {\n    this._groups = [];\n    this._groupKeys = {};\n  };\n\n  __proto.getStatus = function (startKey, endKey) {\n    var datas = this._groups;\n    var startIndex = Math.max(this.indexOf(startKey), 0);\n    var endIndex = this.indexOf(endKey) + 1 || datas.length;\n    return {\n      _data: datas.slice(startIndex, endIndex).map(function (data) {\n        var items = data.items.map(function (item) {\n          var item2 = {};\n          ITEM_KEYS.forEach(function (key) {\n            if (key in item) {\n              item2[key] = item[key];\n            }\n          });\n          return item2;\n        });\n        var data2 = assign({}, data);\n        data2.items = items;\n        return data2;\n      })\n    };\n  };\n\n  __proto.setStatus = function (status) {\n    var _this = this;\n\n    var data = status._data;\n    this.clear();\n    data.forEach(function (group, i) {\n      _this.insertGroup(group, i);\n    });\n  };\n\n  __proto.size = function () {\n    return this._groups.length;\n  };\n\n  __proto.fit = function (base, horizontal) {\n    var groups = this._groups;\n\n    if (!groups.length) {\n      return;\n    }\n\n    var property = horizontal ? \"left\" : \"top\";\n\n    if (base !== 0) {\n      groups.forEach(function (group) {\n        var items = group.items,\n            outlines = group.outlines;\n        items.forEach(function (item) {\n          item.rect[property] -= base;\n        });\n        outlines.start = outlines.start.map(function (start) {\n          return start - base;\n        });\n        outlines.end = outlines.end.map(function (end) {\n          return end - base;\n        });\n      });\n    }\n  };\n\n  __proto.pluck = function (property, start, end) {\n    var data = isUndefined(start) ? this._groups : this.sliceGroups(start, (isUndefined(end) ? start : end) + 1);\n    return ItemManager.pluck(data, property);\n  };\n\n  __proto.getOutline = function (index, property) {\n    var data = this._groups[index];\n    return data ? data.outlines[property] : [];\n  };\n\n  __proto.getEdgeIndex = function (cursor, start, end) {\n    var prop = cursor === \"start\" ? \"min\" : \"max\";\n    var index = -1;\n    var targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n    for (var i = start; i <= end; i++) {\n      var value = Math[prop].apply(Math, this.getOutline(i, cursor));\n\n      if (cursor === \"start\" && targetValue > value || cursor === \"end\" && targetValue < value) {\n        targetValue = value;\n        index = i;\n      }\n    }\n\n    return index;\n  };\n\n  __proto.getEdgeValue = function (cursor, start, end) {\n    var group = this.getGroup(this.getEdgeIndex(cursor, start, end));\n\n    if (group) {\n      var outlines = group.outlines[cursor];\n\n      if (outlines.length) {\n        return Math[cursor === \"start\" ? \"min\" : \"max\"].apply(Math, outlines);\n      }\n    }\n\n    return 0;\n  };\n\n  __proto.clearOutlines = function (startCursor, endCursor) {\n    if (startCursor === void 0) {\n      startCursor = -1;\n    }\n\n    if (endCursor === void 0) {\n      endCursor = -1;\n    }\n\n    var datas = this.getGroups();\n    datas.forEach(function (group, cursor) {\n      if (startCursor <= cursor && cursor <= endCursor) {\n        return;\n      }\n\n      group.items.forEach(function (item) {\n        item.rect.top = DUMMY_POSITION;\n        item.rect.left = DUMMY_POSITION;\n      });\n      group.outlines.start = [];\n      group.outlines.end = [];\n    });\n  };\n\n  __proto.getMaxEdgeValue = function () {\n    var groups = this._groups;\n    var length = groups.length;\n\n    for (var i = length - 1; i >= 0; --i) {\n      var end = groups[i].outlines.end;\n\n      if (end.length) {\n        var pos = Math.max.apply(Math, end);\n        return pos;\n      }\n    }\n\n    return 0;\n  };\n\n  __proto.prependGroup = function (group) {\n    return this.insertGroup(group, 0);\n  };\n\n  __proto.appendGroup = function (group) {\n    return this.insertGroup(group, this._groups.length);\n  };\n\n  __proto.insertGroup = function (group, groupIndex) {\n    var _this = this;\n\n    if (groupIndex < 0) {\n      return this.appendGroup(group);\n    }\n\n    var prevItems = group.items || [];\n\n    var newGroup = _assign(_assign({\n      outlines: {\n        start: [],\n        end: []\n      }\n    }, group), {\n      items: [],\n      needUpdate: true\n    });\n\n    this._groups.splice(groupIndex, 0, newGroup);\n\n    this._groupKeys[newGroup.groupKey] = newGroup;\n    prevItems.forEach(function (item, i) {\n      _this.insert(item, groupIndex, i);\n    });\n    return newGroup;\n  };\n\n  __proto.sync = function (items) {\n    var _this = this;\n\n    var groups = this._groups;\n    var groupKeys = this._groupKeys;\n    var newGroups = categorize(items);\n    var result = diff(groups, newGroups, function (group) {\n      return group.groupKey;\n    });\n    var removed = result.removed,\n        added = result.added,\n        maintained = result.maintained;\n    removed.forEach(function (removedIndex) {\n      var group = groups[removedIndex];\n\n      if (!group) {\n        return;\n      }\n\n      delete groupKeys[group.groupKey];\n    });\n    var nextGroups = [];\n    maintained.forEach(function (_a) {\n      var fromIndex = _a[0];\n      nextGroups.push(groups[fromIndex]);\n    });\n    this._groups = nextGroups;\n    added.forEach(function (addedIndex) {\n      _this.insertGroup(newGroups[addedIndex], addedIndex);\n    });\n    maintained.reverse().forEach(function (_a) {\n      var toIndex = _a[1];\n\n      _this.syncItems(toIndex, newGroups[toIndex].items);\n    });\n    return result;\n  };\n\n  __proto.insert = function (newItem, groupIndex, itemIndex) {\n    if (groupIndex === void 0) {\n      groupIndex = -1;\n    }\n\n    if (itemIndex === void 0) {\n      itemIndex = -1;\n    }\n\n    var groupKey = newItem.groupKey;\n    var groups = this._groups;\n    var groupKeys = this._groupKeys;\n    var group = (groupIndex > -1 ? groups[groupIndex] : groupKeys[groupKey]) || this.insertGroup({\n      groupKey: groupKey\n    }, groupIndex);\n\n    if (!group) {\n      return null;\n    }\n\n    group.needUpdate = true;\n\n    var groupItem = _assign({\n      content: \"\",\n      mounted: false,\n      needUpdate: true,\n      rect: {\n        top: DUMMY_POSITION,\n        left: DUMMY_POSITION\n      }\n    }, newItem);\n\n    var groupItems = group.items;\n\n    if (itemIndex === -1) {\n      groupItems.push(groupItem);\n    } else {\n      groupItems.splice(itemIndex, 0, groupItem);\n    }\n\n    return groupItem;\n  };\n\n  __proto.removeGroup = function (groupIndex) {\n    var group = this._groups.splice(groupIndex, 1)[0];\n\n    if (!group) {\n      return null;\n    }\n\n    delete this._groupKeys[group.groupKey];\n    return group;\n  };\n\n  __proto.remove = function (groupIndex, itemIndex) {\n    var data = this.getGroup(groupIndex);\n    var group = null;\n    var items = [];\n\n    if (!data) {\n      return {\n        items: items,\n        group: group\n      };\n    }\n\n    data.needUpdate = true; // remove item information\n\n    items = data.items.splice(itemIndex, 1);\n\n    if (!data.items.length) {\n      group = this.removeGroup(groupIndex);\n    }\n\n    return {\n      items: items,\n      group: group\n    };\n  };\n\n  __proto.indexOf = function (data) {\n    if (typeof data === \"undefined\") {\n      return -1;\n    }\n\n    var groupKey = \"\" + (typeof data === \"object\" ? data.groupKey : data);\n    var datas = this._groups;\n    var length = datas.length;\n\n    for (var i = 0; i < length; ++i) {\n      if (groupKey === \"\" + datas[i].groupKey) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  __proto.indexesOfElement = function (element) {\n    var groupKey = element.getAttribute(GROUPKEY_ATT);\n    var groupIndex = this.indexOf({\n      groupKey: groupKey\n    });\n    var itemIndex = -1;\n\n    if (groupIndex > -1) {\n      var data = this.getGroup(groupIndex);\n      var length = data.items.length;\n\n      for (var i = 0; i < length; i++) {\n        if (data.items[i].el === element) {\n          itemIndex = i;\n          break;\n        }\n      }\n    }\n\n    return {\n      groupIndex: groupIndex,\n      itemIndex: itemIndex\n    };\n  };\n\n  __proto.sliceGroups = function (start, end) {\n    return this._groups.slice(start, end);\n  };\n\n  __proto.getGroups = function () {\n    return this._groups;\n  };\n\n  __proto.getGroupByKey = function (key) {\n    return this._groupKeys[key];\n  };\n\n  __proto.getGroup = function (index) {\n    return this._groups[index];\n  };\n\n  __proto.syncItems = function (groupIndex, newItems) {\n    var _this = this;\n\n    if (!newItems.length) {\n      this.removeGroup(groupIndex);\n      return;\n    }\n\n    var items = this.getGroup(groupIndex).items;\n\n    var _a = diff(items, newItems, function (item) {\n      return item.itemKey;\n    }),\n        added = _a.added,\n        maintained = _a.maintained,\n        changed = _a.changed,\n        removed = _a.removed;\n\n    var group = this._groups[groupIndex];\n    var nextItems = [];\n    maintained.forEach(function (_a) {\n      var fromIndex = _a[0],\n          nextIndex = _a[1];\n      var item = items[fromIndex];\n      var newItem = newItems[nextIndex];\n      assign(item, newItem);\n      nextItems.push(item);\n    });\n    group.items = nextItems;\n\n    if (changed.length || removed.length) {\n      group.needUpdate = true;\n    }\n\n    added.forEach(function (addedIndex) {\n      _this.insert(newItems[addedIndex], groupIndex, addedIndex);\n    });\n  };\n\n  return ItemManager;\n}();\n\nfunction removeTransition(style) {\n  style[TRANSITION + \"-property\"] = \"\";\n  style[TRANSITION + \"-duration\"] = \"\";\n  style[TRANSFORM] = \"\";\n}\n\nfunction setTransition(style, transitionDuration, pos1, pos2) {\n  if (!transitionDuration) {\n    removeTransition(style);\n    return false;\n  }\n\n  if (pos1.left === pos2.left && pos1.top === pos2.top) {\n    return false;\n  }\n\n  style[TRANSITION + \"-property\"] = TRANSFORM + \",width,height\";\n  style[TRANSITION + \"-duration\"] = transitionDuration + \"s\";\n  style[TRANSFORM] = \"translate(\" + (pos1.left - pos2.left) + \"px,\" + (pos1.top - pos2.top) + \"px)\";\n  return true;\n}\n\nfunction createContainer(element) {\n  var selectContainer = element.querySelector(\".\" + CONTAINER_CLASSNAME);\n\n  if (selectContainer) {\n    selectContainer.style.position = \"relative\";\n    selectContainer.style.height = \"100%\";\n    return selectContainer;\n  }\n\n  var container = document.createElement(\"div\");\n  container.className = CONTAINER_CLASSNAME;\n  container.style.position = \"relative\";\n  container.style.height = \"100%\";\n  var children = element.children;\n  var length = children.length; // for IE8\n\n  for (var i = 0; i < length; i++) {\n    container.appendChild(children[0]);\n  }\n\n  element.appendChild(container);\n  return container;\n}\n\nvar DOMRenderer = /*#__PURE__*/function () {\n  function DOMRenderer(element, options) {\n    this.options = {\n      useOffset: false,\n      isEqualSize: false,\n      isConstantSize: false,\n      horizontal: false,\n      container: false,\n      percentage: false\n    };\n    this._size = {\n      container: -1,\n      view: -1,\n      viewport: -1,\n      item: null\n    };\n    this._orgStyle = {};\n    this._isSizePercentage = false;\n    this._isPosPercentage = false;\n    assign(this.options, options);\n\n    this._init(element);\n\n    this.resize();\n  }\n\n  var __proto = DOMRenderer.prototype;\n\n  DOMRenderer.removeItems = function (items) {\n    items.forEach(function (item) {\n      if (item.el) {\n        DOMRenderer.removeElement(item.el);\n        item.el = null;\n      }\n    });\n  };\n\n  DOMRenderer.removeElement = function (element) {\n    var parentNode = element && element.parentNode;\n\n    if (!parentNode) {\n      return;\n    }\n\n    parentNode.removeChild(element);\n  };\n\n  DOMRenderer.createElements = function (items) {\n    if (!items.length) {\n      return;\n    }\n\n    var noElementItems = items.filter(function (item) {\n      return !item.el;\n    });\n\n    if (!noElementItems.length) {\n      return;\n    }\n\n    var elements = $(noElementItems.map(function (_a) {\n      var content = _a.content;\n      return content.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, \"\");\n    }).join(\"\"), true);\n    noElementItems.forEach(function (item, index) {\n      item.el = elements[index];\n    });\n  };\n\n  __proto.getStatus = function () {\n    return {\n      cssText: this.container.style.cssText,\n      _size: assign({}, this._size)\n    };\n  };\n\n  __proto.setStatus = function (status) {\n    this.container.style.cssText = status.cssText;\n    assign(this._size, status._size);\n  };\n\n  __proto.updateSize = function (items) {\n    var _a = this.options,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize,\n        useOffset = _a.useOffset;\n    var size = this._size;\n    return items.map(function (item) {\n      if (!item.el) {\n        return item;\n      }\n\n      if (isEqualSize && !size.item) {\n        size.item = useOffset ? getOffsetSize(item.el) : getRectSize(item.el);\n      }\n\n      item.size = isEqualSize && assign({}, size.item) || isConstantSize && item.orgSize && item.orgSize.width && assign({}, item.orgSize) || (useOffset ? getOffsetSize(item.el) : getRectSize(item.el));\n\n      if (!item.orgSize || !item.orgSize.width || !item.orgSize.height) {\n        item.orgSize = assign({}, item.size);\n      }\n\n      return item;\n    });\n  };\n\n  __proto.createAndInsert = function (items, isAppend) {\n    DOMRenderer.createElements(items);\n    this.renderItems(items);\n\n    this._insert(items, isAppend);\n  };\n\n  __proto.renderItems = function (items, transitionDuration) {\n    var _this = this;\n\n    items.forEach(function (item) {\n      _this.renderItem(item, item.rect, transitionDuration);\n    });\n  };\n\n  __proto.renderItem = function (item, rect, transitionDuration) {\n    var _this = this;\n\n    if (!item.el) {\n      return;\n    }\n\n    var el = item.el,\n        prevRect = item.prevRect;\n    var style = el.style;\n    el.setAttribute(GROUPKEY_ATT, \"\" + item.groupKey);\n    style.position = \"absolute\";\n\n    this._render([\"width\", \"height\"], rect, style);\n\n    if (transitionDuration && TRANSITION && prevRect) {\n      setTransition(style, transitionDuration, rect, prevRect);\n\n      if (el[TRANSITION_NAME]) {\n        return;\n      }\n\n      el[TRANSITION_NAME] = true;\n      addOnceEvent(el, TRANSITION_END, function () {\n        var itemRect = item.rect;\n        removeTransition(style);\n\n        _this._render([\"left\", \"top\"], itemRect, style);\n\n        item.prevRect = itemRect;\n        el[TRANSITION_NAME] = false;\n      });\n    } else {\n      this._render([\"left\", \"top\"], rect, style);\n\n      item.prevRect = rect;\n    }\n  };\n\n  __proto.getViewSize = function () {\n    return this._size.view;\n  };\n\n  __proto.getViewportSize = function () {\n    return this._size.viewport;\n  };\n\n  __proto.getContainerSize = function () {\n    return this._size.container;\n  };\n\n  __proto.setContainerSize = function (size) {\n    this._size.container = size;\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = size + \"px\";\n  };\n\n  __proto.resize = function () {\n    var horizontal = this.options.horizontal;\n    var view = this.view;\n\n    var size = this._calcSize();\n\n    if (size === 0) {\n      return;\n    }\n\n    var isResize = size !== this._size.viewport;\n\n    if (isResize) {\n      this._size = {\n        view: -1,\n        container: -1,\n        viewport: size,\n        item: null\n      };\n    }\n\n    this._size.view = horizontal ? getClientWidth(view) : getClientHeight(view);\n    return isResize;\n  };\n\n  __proto.isNeededResize = function () {\n    return this._calcSize() !== this._size.viewport;\n  };\n\n  __proto.clear = function () {\n    this.container.innerHTML = \"\";\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = \"\";\n    this._size = {\n      item: null,\n      viewport: -1,\n      container: -1,\n      view: -1\n    };\n  };\n\n  __proto.destroy = function () {\n    this.clear();\n    var container = this.options.container;\n    var property;\n\n    for (property in this._orgStyle) {\n      this[container ? \"view\" : \"container\"].style[property] = this._orgStyle[property];\n    }\n\n    if (container === true) {\n      this.container.parentNode.removeChild(this.container);\n    }\n  };\n\n  __proto._init = function (el) {\n    var element = $(el);\n    var style = getStyle(element);\n    var _a = this.options,\n        container = _a.container,\n        horizontal = _a.horizontal,\n        percentage = _a.percentage;\n\n    if (percentage) {\n      this._isSizePercentage = percentage === true || percentage.indexOf(\"size\") > -1;\n      this._isPosPercentage = percentage === true || percentage.indexOf(\"position\") > -1;\n    }\n\n    if (style.position === \"static\") {\n      this._orgStyle.position = element.style.position;\n      element.style.position = \"relative\";\n    }\n\n    if (container) {\n      var target = horizontal ? [\"X\", \"Y\"] : [\"Y\", \"X\"];\n      this._orgStyle.overflowX = element.style.overflowX;\n      this._orgStyle.overflowY = element.style.overflowY;\n      element.style[\"overflow\" + target[0]] = \"scroll\";\n      element.style[\"overflow\" + target[1]] = \"hidden\";\n      this.view = element;\n      this.container = container === true ? createContainer(this.view) : container;\n    } else {\n      this.view = win;\n      this.container = element;\n    }\n  };\n\n  __proto._insert = function (items, isAppend, style) {\n    var _this = this;\n\n    var container = this.container;\n    var df = document.createDocumentFragment();\n    items.forEach(function (item) {\n      style && _this.renderItem(item, style);\n      isAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n    });\n    isAppend ? container.appendChild(df) : container.insertBefore(df, container.firstChild);\n  };\n\n  __proto._calcSize = function () {\n    return this.options.horizontal ? getClientHeight(this.container) : getClientWidth(this.container);\n  };\n\n  __proto._render = function (properties, rect, style) {\n    var isSizePercentage = this._isSizePercentage;\n    var isPosPercentage = this._isPosPercentage;\n    var viewportSize = this.getViewportSize();\n    var horizontal = this.options.horizontal;\n    properties.forEach(function (p) {\n      if (!(p in rect)) {\n        return;\n      }\n\n      var isHorizontalPercentage = horizontal && (isSizePercentage && p === \"height\" || isPosPercentage && p === \"top\");\n      var isVerticalPercentage = !horizontal && (isSizePercentage && p === \"width\" || isPosPercentage && p === \"left\");\n      style[p] = isHorizontalPercentage || isVerticalPercentage ? rect[p] / viewportSize * 100 + \"%\" : rect[p] + \"px\";\n    });\n  };\n\n  return DOMRenderer;\n}();\n\nfunction isVisible(group, threshold, scrollPos, endScrollPos) {\n  var items = group.items,\n      outlines = group.outlines;\n  var start = outlines.start;\n  var end = outlines.end;\n\n  if (start.length === 0 || end.length === 0 || !items.length || !items[0].el) {\n    return 2;\n  }\n\n  var min = Math.min.apply(Math, start);\n  var max = Math.max.apply(Math, end);\n\n  if (endScrollPos + threshold < min) {\n    return +1;\n  } else if (scrollPos - threshold > max) {\n    return -1;\n  }\n\n  return 0;\n}\n\nvar Infinite = /*#__PURE__*/function () {\n  function Infinite(itemManger, options) {\n    this.options = assign({\n      useRecycle: true,\n      threshold: 100,\n      append: function append() {\n        return void 0;\n      },\n      prepend: function prepend() {\n        return void 0;\n      },\n      recycle: function recycle() {\n        return void 0;\n      }\n    }, options);\n    this._itemManager = itemManger;\n    this.clear();\n  }\n\n  var __proto = Infinite.prototype;\n\n  __proto.setSize = function (size) {\n    this._status.size = size;\n  };\n\n  __proto.sync = function (items) {\n    var status = this._status;\n    var startCursor = status.startCursor,\n        endCursor = status.endCursor;\n    var itemManager = this._itemManager;\n    var prevVisisbleGroups = itemManager.sliceGroups(startCursor, endCursor + 1);\n    var prevVisibleItems = ItemManager.pluck(prevVisisbleGroups, \"items\");\n    var result = itemManager.sync(items);\n    var startGroup = find(prevVisisbleGroups, function (_a) {\n      var groupKey = _a.groupKey;\n      return itemManager.getGroupByKey(groupKey);\n    });\n    var endGroup = findLast(prevVisisbleGroups, function (_a) {\n      var groupKey = _a.groupKey;\n      return itemManager.getGroupByKey(groupKey);\n    });\n    var nextStartCursor = startGroup ? itemManager.indexOf(startGroup) : -1;\n    var nextEndCursor = endGroup ? itemManager.indexOf(endGroup) : -1;\n\n    if (nextStartCursor > -1 && nextEndCursor > -1) {\n      // This is when the arrangement is inverted.\n      // prevVisisbleGroups is [0, 1, 2, 3]\n      // but currentGroups is [3, 2, 1, 0]\n      // so, nextStartCursor is 3, and nextEndCursor is 0\n      var minCursor = Math.min(nextStartCursor, nextEndCursor);\n      var maxCursor = Math.max(nextStartCursor, nextEndCursor);\n      nextStartCursor = minCursor;\n      nextEndCursor = maxCursor;\n    } else if (nextEndCursor > -1) {\n      nextStartCursor = nextEndCursor;\n    } else if (nextStartCursor > -1) {\n      nextEndCursor = nextStartCursor;\n    }\n\n    status.startCursor = nextStartCursor;\n    status.endCursor = nextEndCursor;\n\n    if (result.removed.length > 0) {\n      return \"relayout\";\n    } else {\n      var nextVisibleItems = itemManager.pluck(\"items\", startCursor, endCursor);\n\n      var _a = diff(prevVisibleItems, nextVisibleItems, function (_a) {\n        var itemKey = _a.itemKey;\n        return itemKey;\n      }),\n          visibleAdded = _a.added,\n          visibleRemoved = _a.removed,\n          visibleChanged = _a.changed;\n\n      if (!visibleAdded.length && (visibleChanged.length > 0 || visibleRemoved.length > 0)) {\n        return \"layout\";\n      } else {\n        return \"\";\n      }\n    }\n  };\n\n  __proto.recycle = function (scrollPos, isForward) {\n    if (!this.options.useRecycle || typeof scrollPos !== \"number\") {\n      return;\n    }\n\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor,\n        size = _a.size;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return;\n    }\n\n    var endScrollPos = scrollPos + size;\n    var _b = this.options,\n        threshold = _b.threshold,\n        recycle = _b.recycle;\n\n    var visibles = this._itemManager.sliceGroups(startCursor, endCursor + 1).map(function (group) {\n      return isVisible(group, threshold, scrollPos, endScrollPos);\n    });\n\n    var length = visibles.length;\n    var start = isForward ? 0 : visibles.lastIndexOf(0);\n    var end = isForward ? visibles.indexOf(0) - 1 : visibles.length - 1;\n\n    if (!isForward && start !== -1) {\n      start += 1;\n    }\n\n    if (start < 0 || end < 0 || start > end || end - start + 1 >= length) {\n      return;\n    }\n\n    start = startCursor + start;\n    end = startCursor + end;\n\n    if (isForward) {\n      this.setCursor(\"start\", end + 1);\n    } else {\n      this.setCursor(\"end\", start - 1);\n    }\n\n    recycle({\n      start: start,\n      end: end\n    });\n  };\n\n  __proto.scroll = function (scrollPos) {\n    var _a = this.getCursors(),\n        startCursor = _a[0],\n        endCursor = _a[1];\n\n    var items = this._itemManager;\n\n    if (typeof scrollPos !== \"number\" || startCursor === -1 || endCursor === -1 || !items.size()) {\n      return;\n    }\n\n    var size = this._status.size;\n    var _b = this.options,\n        threshold = _b.threshold,\n        append = _b.append,\n        prepend = _b.prepend;\n    var datas = items.getGroups();\n    var endScrollPos = scrollPos + size;\n    var startEdgePos = Math.max.apply(Math, datas[startCursor].outlines.start);\n    var endEdgePos = Math.min.apply(Math, datas[endCursor].outlines.end);\n    var visibles = datas.map(function (group, i) {\n      var _a = group.outlines,\n          start = _a.start,\n          end = _a.end;\n\n      if (!start.length || !end.length) {\n        return false;\n      }\n\n      var startPos = Math.min.apply(Math, start);\n      var endPos = Math.max.apply(Math, end);\n\n      if (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n        return true;\n      }\n\n      return false;\n    });\n    var startIndex = visibles.indexOf(true);\n    var endIndex = visibles.lastIndexOf(true);\n\n    if (~startIndex && startIndex < startCursor) {\n      prepend({\n        cache: datas.slice(startIndex, Math.min(startCursor, endIndex + 1))\n      });\n    } else if (endCursor < endIndex) {\n      append({\n        cache: datas.slice(Math.max(startIndex, endCursor + 1), endIndex + 1)\n      });\n    } else {\n      // if you have data(no cachedAppendData, has cachedPrependData) to pepend, request it.\n      var cachedAppendData = datas.slice(endCursor + 1, endCursor + 2);\n      var cachedPrependData = datas.slice(startCursor - 1, startCursor);\n      var isPrepend = scrollPos <= startEdgePos + threshold;\n\n      if (endScrollPos >= endEdgePos - threshold && (!isPrepend || cachedAppendData.length || !cachedPrependData.length)) {\n        append({\n          cache: cachedAppendData\n        });\n      } else if (isPrepend) {\n        prepend({\n          cache: cachedPrependData\n        });\n      }\n    }\n  };\n\n  __proto.setCursor = function (cursor, index) {\n    var status = this._status;\n    var items = this._itemManager;\n    var size = items.size();\n\n    if (!this.options.useRecycle) {\n      status.startCursor = 0;\n\n      if (items.getOutline(size - 1, \"end\").length) {\n        status.endCursor = size - 1;\n        return;\n      }\n\n      if (cursor !== \"end\") {\n        return;\n      }\n    }\n\n    if (cursor === \"start\") {\n      status.startCursor = index;\n    } else {\n      status.endCursor = Math.min(size - 1, index);\n    }\n\n    status.startCursor = Math.max(0, status.startCursor);\n  };\n\n  __proto.setStatus = function (status) {\n    this._status = assign(this._status, status);\n  };\n\n  __proto.getStatus = function (startKey, endKey) {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor,\n        size = _a.size;\n    var startIndex = Math.max(this._itemManager.indexOf(startKey), 0);\n    var endIndex = (this._itemManager.indexOf(endKey) + 1 || this._itemManager.size()) - 1;\n    var start = Math.max(startCursor - startIndex, ~startCursor ? 0 : -1);\n    var end = Math.max(Math.min(endCursor - startIndex, endIndex - startIndex), start);\n    return {\n      startCursor: start,\n      endCursor: end,\n      size: size\n    };\n  };\n\n  __proto.getEdgeOutline = function (cursor) {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return [];\n    }\n\n    return this._itemManager.getOutline(cursor === \"start\" ? startCursor : endCursor, cursor);\n  };\n\n  __proto.getEdgeValue = function (cursor) {\n    var outlines = this.getEdgeOutline(cursor);\n    return outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"].apply(Math, outlines) : 0;\n  };\n\n  __proto.getVisibleItems = function () {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor;\n    return this._itemManager.pluck(\"items\", startCursor, endCursor);\n  };\n\n  __proto.getCursors = function () {\n    var status = this._status;\n    return [status.startCursor, status.endCursor];\n  };\n\n  __proto.getCursor = function (cursor) {\n    return this._status[cursor === \"start\" ? \"startCursor\" : \"endCursor\"];\n  };\n\n  __proto.getVisibleData = function () {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor;\n    return this._itemManager.sliceGroups(startCursor, endCursor + 1);\n  };\n\n  __proto.remove = function (groupIndex, itemIndex) {\n    var status = this._status;\n    var items = this._itemManager;\n    var startCursor = status.startCursor,\n        endCursor = status.endCursor;\n    var result = items.remove(groupIndex, itemIndex);\n\n    if (result.group) {\n      if (groupIndex < startCursor) {\n        this.setCursor(\"start\", startCursor - 1);\n      }\n\n      if (groupIndex <= endCursor) {\n        this.setCursor(\"end\", endCursor - 1);\n      }\n    }\n\n    if (!items.size()) {\n      status.startCursor = -1;\n      status.endCursor = -1;\n    }\n\n    return result;\n  };\n\n  __proto.clear = function () {\n    this._status = {\n      startCursor: -1,\n      endCursor: -1,\n      size: -1\n    };\n  };\n\n  return Infinite;\n}();\n\nfunction hasTarget(target, value) {\n  return ~target.indexOf(value);\n}\n\nvar RenderManager = /*#__PURE__*/function () {\n  function RenderManager(_infinite, _itemManager, _renderer, options) {\n    this._infinite = _infinite;\n    this._itemManager = _itemManager;\n    this._renderer = _renderer;\n    this.options = options;\n  }\n\n  var __proto = RenderManager.prototype;\n\n  __proto.setLayout = function (layout) {\n    this._layout = layout;\n  };\n\n  __proto.render = function (callbackComponent, groups, items, isAppend) {\n    var _this = this;\n\n    if (items === void 0) {\n      items = ItemManager.pluck(groups, \"items\");\n    }\n\n    var checkGroups = isAppend ? groups : groups.reverse();\n    var replaceTarget = [];\n    var removeTarget = [];\n    var elements = items.map(function (item) {\n      return item.el;\n    });\n    var prefix = this.options.attributePrefix;\n    var im = new ImReady({\n      prefix: prefix\n    });\n    this.im = im;\n    im.check(elements);\n    im.on(\"preReady\", function () {\n      if (!_this._itemManager) {\n        return;\n      }\n\n      _this._preReady(callbackComponent, checkGroups, items, isAppend);\n    }).on(\"error\", function (_a) {\n      var target = _a.target,\n          index = _a.index;\n\n      if (!_this._itemManager) {\n        return;\n      }\n\n      _this._error(callbackComponent, removeTarget, replaceTarget, target, items, index);\n    }).on(\"readyElement\", function (e) {\n      var item = items[e.index];\n      item.needUpdate = false;\n\n      if (e.hasLoading && e.isPreReadyOver) {\n        _this._readyElement(callbackComponent, items[e.index]);\n      }\n    }).on(\"ready\", function () {\n      if (!_this._itemManager) {\n        return;\n      }\n\n      _this._ready(callbackComponent, removeTarget, replaceTarget, items);\n    });\n    return callbackComponent;\n  };\n\n  __proto.destroy = function () {\n    this.im && this.im.destroy();\n  };\n\n  __proto._preReady = function (callbackComponent, groups, items, isAppend) {\n    var _this = this;\n\n    var infinite = this._infinite;\n    var layout = this._layout;\n    var itemManager = this._itemManager;\n    var insertCursor = isAppend ? \"end\" : \"start\";\n    var outlineCursor = isAppend ? \"start\" : \"end\";\n    var groupIndex = itemManager.indexOf(groups[0]);\n    var startGroup = itemManager.getGroup(groupIndex);\n    var prevGroup = itemManager.getGroup(groupIndex + (isAppend ? -1 : 1));\n    var outline = [0];\n\n    if (prevGroup) {\n      outline = prevGroup.outlines[insertCursor];\n    } else if (startGroup) {\n      outline = startGroup.outlines[outlineCursor];\n    }\n\n    this._renderer.updateSize(items);\n\n    groups.forEach(function (group) {\n      var groupOutline = group.outlines[outlineCursor];\n      var isRelayout = group.needUpdate || !outline.length || (outline.length === groupOutline.length ? !outline.every(function (v, index) {\n        return v === groupOutline[index];\n      }) : true);\n\n      if (!isRelayout) {\n        outline = group.outlines[insertCursor];\n\n        _this._renderer.renderItems(group.items);\n\n        return;\n      }\n\n      var groupItems = group.items;\n      var groupInfo = layout[isAppend ? \"append\" : \"prepend\"](groupItems, outline, true);\n      assign(group, groupInfo);\n\n      _this._renderer.renderItems(groupInfo.items);\n\n      outline = groupInfo.outlines[insertCursor];\n      group.needUpdate = false;\n    });\n    var startCursor = Math.max(infinite.getCursor(\"start\"), 0);\n    var endCursor = Math.max(infinite.getCursor(\"end\"), 0);\n    var requestStartCursor = itemManager.indexOf(groups[0].groupKey);\n    var requestEndCursor = itemManager.indexOf(groups[groups.length - 1].groupKey);\n    var isInCursor = true;\n\n    if (requestStartCursor > endCursor + 1 || requestEndCursor < startCursor - 1) {\n      isInCursor = false;\n    }\n\n    if (isInCursor) {\n      if (isAppend) {\n        requestStartCursor = startCursor;\n        requestEndCursor = Math.max(endCursor, requestEndCursor);\n      } else {\n        requestStartCursor = Math.max(Math.min(startCursor, requestStartCursor), 0);\n        requestEndCursor = endCursor;\n      }\n    }\n\n    if (requestStartCursor > requestEndCursor) {\n      var tempCursor = requestStartCursor;\n      requestStartCursor = requestEndCursor;\n      requestEndCursor = tempCursor;\n    }\n\n    callbackComponent.trigger(\"renderComplete\", {\n      start: requestStartCursor,\n      end: requestEndCursor\n    });\n    callbackComponent.trigger(\"layoutComplete\", {\n      items: ItemManager.pluck(groups, \"items\"),\n      isAppend: !!isAppend\n    });\n  };\n\n  __proto._error = function (callbackComponent, removeTarget, replaceTarget, target, items, errorIndex) {\n    var itemManager = this._itemManager;\n    var item = items[errorIndex];\n    var element = item.el;\n    var prefix = this.options.attributePrefix; // remove item\n\n    var removeItem = function removeItem() {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      removeTarget.push(element);\n      var index = replaceTarget.indexOf(errorIndex);\n      index !== -1 && replaceTarget.splice(index, 1);\n    }; // remove image\n\n\n    var remove = function remove() {\n      if (target === element) {\n        removeItem();\n        return;\n      }\n\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      target.parentNode.removeChild(target);\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace image\n\n\n    var replace = function replace(src) {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      if (src) {\n        if (matchHTML(src) || typeof src === \"object\") {\n          var parentNode = target.parentNode;\n          parentNode.insertBefore($(src), target);\n          parentNode.removeChild(target);\n          item.content = element.outerHTML;\n        } else if (target instanceof HTMLImageElement) {\n          target.src = src;\n\n          if (target.getAttribute(prefix + \"width\")) {\n            target.removeAttribute(prefix + \"width\");\n            target.removeAttribute(prefix + \"height\");\n          }\n        }\n      }\n\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace item\n\n\n    var replaceItem = function replaceItem(content) {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      element.innerHTML = content;\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    };\n\n    var totalIndex = itemManager.pluck(\"items\").indexOf(item);\n\n    if (target instanceof HTMLImageElement) {\n      callbackComponent.trigger(\"imageError\", {\n        target: target,\n        element: element,\n        items: items,\n        item: item,\n        itemIndex: errorIndex,\n        replace: replace,\n        replaceItem: replaceItem,\n        remove: remove,\n        removeItem: removeItem,\n        totalIndex: totalIndex\n      });\n    }\n\n    callbackComponent.trigger(\"contentError\", {\n      target: target,\n      element: element,\n      items: items,\n      item: item,\n      itemIndex: errorIndex,\n      replace: replace,\n      replaceItem: replaceItem,\n      remove: remove,\n      removeItem: removeItem,\n      totalIndex: totalIndex\n    });\n  };\n\n  __proto._readyElement = function (callbackComponent, item) {\n    callbackComponent.trigger(\"readyElement\", {\n      item: item\n    });\n  };\n\n  __proto._ready = function (callbackComponent, removeTarget, replaceTarget, items) {\n    var _this = this;\n\n    var attributePrefix = this.options.attributePrefix;\n    var removeTargetLength = removeTarget.length;\n    var replaceTargetLength = replaceTarget.length;\n\n    if (!removeTargetLength && !replaceTargetLength) {\n      callbackComponent.trigger(\"ready\", {\n        remove: []\n      });\n      return;\n    }\n\n    var layoutedItems = replaceTarget.map(function (itemIndex) {\n      return items[itemIndex];\n    });\n\n    if (!replaceTargetLength) {\n      callbackComponent.trigger(\"ready\", {\n        remove: removeTarget,\n        layout: true\n      });\n      return;\n    } // wait layoutComplete beacause of error event.\n\n\n    new ImReady({\n      prefix: attributePrefix\n    }).check(layoutedItems.map(function (v) {\n      return v.el;\n    })).on(\"ready\", function () {\n      _this._renderer.updateSize(layoutedItems);\n\n      callbackComponent.trigger(\"ready\", {\n        remove: removeTarget,\n        layout: true\n      });\n    });\n  };\n\n  return RenderManager;\n}();\n\nvar Watcher = /*#__PURE__*/function () {\n  function Watcher(view, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._resizeTimer = 0;\n    this._maxResizeDebounceTimer = 0;\n    this._containerOffset = 0;\n    this._isScrollIssue = IS_IOS; //  When InfiniteGrid is initialized.\n    // The initial value is null to block the scroll event when returning from browser behavior.\n\n    this._prevPos = null;\n\n    this._onCheck = function () {\n      var prevPos = _this.getScrollPos();\n\n      var orgScrollPos = _this.getOrgScrollPos();\n\n      _this.setScrollPos(orgScrollPos);\n\n      var scrollPos = _this.getScrollPos();\n\n      if (prevPos === null || _this._isScrollIssue && orgScrollPos === 0 || prevPos === scrollPos) {\n        orgScrollPos && (_this._isScrollIssue = false);\n        return;\n      }\n\n      _this._isScrollIssue = false;\n\n      _this.options.check({\n        isForward: prevPos < scrollPos,\n        scrollPos: scrollPos,\n        orgScrollPos: orgScrollPos,\n        horizontal: _this.options.horizontal\n      });\n    };\n\n    this._onResize = function () {\n      var _a = _this.options,\n          resizeDebounce = _a.resizeDebounce,\n          maxResizeDebounce = _a.maxResizeDebounce;\n\n      var onResize = function onResize() {\n        clearTimeout(_this._resizeTimer);\n        clearTimeout(_this._maxResizeDebounceTimer);\n        _this._maxResizeDebounceTimer = 0;\n        _this._resizeTimer = 0;\n\n        _this.resize();\n\n        _this.options.resize();\n      };\n\n      if (!_this._maxResizeDebounceTimer && maxResizeDebounce >= resizeDebounce) {\n        _this._maxResizeDebounceTimer = win.setTimeout(onResize, maxResizeDebounce);\n      }\n\n      if (_this._resizeTimer) {\n        clearTimeout(_this._resizeTimer);\n        _this._resizeTimer = 0;\n      }\n\n      _this._resizeTimer = win.setTimeout(onResize, resizeDebounce);\n    };\n\n    assign(this.options = {\n      container: view,\n      resize: function resize() {\n        return void 0;\n      },\n      check: function check() {\n        return void 0;\n      },\n      isOverflowScroll: false,\n      horizontal: false,\n      resizeDebounce: 100,\n      maxResizeDebounce: 0\n    }, options);\n    this._view = view;\n    this.attachEvent();\n    this.resize();\n    this.setScrollPos();\n  }\n\n  var __proto = Watcher.prototype;\n\n  __proto.getStatus = function () {\n    return {\n      _prevPos: this._prevPos,\n      scrollPos: this.getOrgScrollPos()\n    };\n  };\n\n  __proto.setStatus = function (status, applyScrollPos) {\n    if (applyScrollPos === void 0) {\n      applyScrollPos = true;\n    }\n\n    this._prevPos = status._prevPos;\n    applyScrollPos && this.scrollTo(status.scrollPos);\n  };\n\n  __proto.scrollBy = function (pos) {\n    var arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n    scrollBy(this._view, arrPos[0], arrPos[1]);\n    this.setScrollPos();\n  };\n\n  __proto.scrollTo = function (pos) {\n    var arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n    scrollTo(this._view, arrPos[0], arrPos[1]);\n  };\n\n  __proto.getScrollPos = function () {\n    return this._prevPos;\n  };\n\n  __proto.setScrollPos = function (pos) {\n    if (pos === void 0) {\n      pos = this.getOrgScrollPos();\n    }\n\n    this._prevPos = pos - this.getContainerOffset();\n  };\n\n  __proto.attachEvent = function () {\n    addEvent(this._view, \"scroll\", this._onCheck);\n    addEvent(win, \"resize\", this._onResize);\n  };\n\n  __proto.getOrgScrollPos = function () {\n    return scroll(this._view, this.options.horizontal);\n  };\n\n  __proto.reset = function () {\n    this._prevPos = null;\n  };\n\n  __proto.getContainerOffset = function () {\n    return this._containerOffset;\n  };\n\n  __proto.resize = function () {\n    this._containerOffset = this.options.isOverflowScroll ? 0 : this._getOffset();\n  };\n\n  __proto.detachEvent = function () {\n    removeEvent(this._view, \"scroll\", this._onCheck);\n    removeEvent(win, \"resize\", this._onResize);\n  };\n\n  __proto.destroy = function () {\n    this.detachEvent();\n    this.reset();\n  };\n\n  __proto._getOffset = function () {\n    var _a = this.options,\n        container = _a.container,\n        horizontal = _a.horizontal;\n    var rect = container.getBoundingClientRect();\n    return rect[horizontal ? \"left\" : \"top\"] + this.getOrgScrollPos();\n  };\n\n  return Watcher;\n}(); // https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n\n/* eslint-disable */\n// if (typeof Object.create !== \"function\") {\n//   // tslint:disable\n//   Object.create = (o: any, properties: any) => {\n//     if (typeof o !== \"object\" && typeof o !== \"function\") {\n//       throw new TypeError(\"Object prototype may only be an Object: \" + o);\n//     } else if (o === null) {\n//       throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n//     }\n//     function F() { }\n//     F.prototype = o;\n//     return new F();\n//   };\n//   // tslint:enable\n// }\n\n/* eslint-enable */\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko          .         .        DOM      \n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n  <li class=\"card\">\n    <div>test1</div>\n  </li>\n  <li class=\"card\">\n    <div>test2</div>\n  </li>\n  <li class=\"card\">\n    <div>test3</div>\n  </li>\n  <li class=\"card\">\n    <div>test4</div>\n  </li>\n  <li class=\"card\">\n    <div>test5</div>\n  </li>\n  <li class=\"card\">\n    <div>test6</div>\n  </li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n  // ...\n});\n\n// If you already have items in the container, call \"layout\" method.\nsome.layout();\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\n\n\nvar InfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(InfiniteGrid, _super);\n  /**\n   * @param {HTMLElement|string|jQuery} element A base element for a module <ko>   </ko>\n   * @param {object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n   * @param {string} [options.itemSelector] A selector to select card elements that make up the layout<ko>     (selector)</ko>\n   * @param {boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM    . useRecycle  'true' DOM   . useRecycle  'false'     DOM   .</ko>\n   * @param {boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll  .</ko>\n   * @param {boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false )</ko>\n   * @param {boolean} [options.useFit=true] The useFit option scrolls upwards so that no space is visible until an item is added <ko>          .</ko>\n   * @param {boolean} [options.useOffset=false] Whether to get the size as offsetWidth, offsetHeight. Set to true if transform is applied to the container. If false, get the size through getBoundingClientRect. <ko> offsetWidth, offsetHeight  .\n  container transform   true . false getBoundingClientRect   .</ko>\n   * @param {boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>    .          'true'       </ko>\n   * @param {boolean} [options.isConstantSize=false] Indicates whether sizes of all card elements does not change, the performance of layout arrangement can be improved. <ko>        'true'       </ko>\n   * @param {number} [options.transitionDruation=0] Indicates how many seconds a transition effect takes to complete. <ko>     .</ko>\n   * @param {number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>        .</ko>\n   * @param {string} [options.attributePrefix=\"data-\"] The prefix to use element's data attribute.<ko>    .</ko>\n   * @param {number} [options.resizeDebounce=100] Debounce time to set in the resize event. <ko>    .</ko>\n   * @param {number} [options.maxResizeDebounce=0] Maximum time to debounce the resize event(0 is not set). <ko>      (0 ).</ko>\n   * @param {boolean} [options.renderExternal=false] Whether to use external rendering. It will delegate DOM manipulation and can synchronize the rendered state by calling `sync()` method. You can use this option to use in frameworks like React, Vue, Angular, which has its states and rendering methods.<ko>    .        , `sync()`      .   , React, Vue, Angular          .</ko>\n   * @param {boolean | Array<\"size\" | \"position\">} [options.percentage=false] Whether to set the css size and position of the item to %.<ko>item css size position %  .</ko>\n   */\n\n\n  function InfiniteGrid(element, options) {\n    var _this = _super.call(this) || this;\n\n    _this._loadingBar = {};\n    _this._requestGroups = [];\n    assign(_this.options = _assign({}, DEFAULT_OPTIONS), options);\n    DEFENSE_BROWSER && (_this.options.useFit = false);\n    IS_ANDROID2 && (_this.options.isOverflowScroll = false);\n\n    _this._reset();\n\n    var _a = _this.options,\n        isOverflowScroll = _a.isOverflowScroll,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize,\n        horizontal = _a.horizontal,\n        threshold = _a.threshold,\n        useRecycle = _a.useRecycle,\n        attributePrefix = _a.attributePrefix,\n        resizeDebounce = _a.resizeDebounce,\n        maxResizeDebounce = _a.maxResizeDebounce,\n        percentage = _a.percentage,\n        useOffset = _a.useOffset;\n    _this._itemManager = new ItemManager();\n    _this._renderer = new DOMRenderer(element, {\n      isEqualSize: isEqualSize,\n      isConstantSize: isConstantSize,\n      horizontal: horizontal,\n      container: isOverflowScroll,\n      percentage: percentage,\n      useOffset: useOffset\n    });\n    _this._watcher = new Watcher(_this._renderer.view, {\n      resizeDebounce: resizeDebounce,\n      maxResizeDebounce: maxResizeDebounce,\n      isOverflowScroll: isOverflowScroll,\n      horizontal: horizontal,\n      container: _this._renderer.container,\n      resize: function resize() {\n        return _this._onResize();\n      },\n      check: function check(param) {\n        return _this._onCheck(param);\n      }\n    });\n    _this._infinite = new Infinite(_this._itemManager, {\n      useRecycle: useRecycle,\n      threshold: threshold,\n      append: function append(param) {\n        return _this._requestAppend(param);\n      },\n      prepend: function prepend(param) {\n        return _this._requestPrepend(param);\n      },\n      recycle: function recycle(param) {\n        return _this._recycle([param]);\n      }\n    });\n    _this._renderManager = new RenderManager(_this._infinite, _this._itemManager, _this._renderer, {\n      attributePrefix: attributePrefix,\n      isEqualSize: isEqualSize,\n      isConstantSize: isConstantSize,\n      horizontal: horizontal\n    });\n    return _this;\n  }\n  /**\n   * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko     . isProcessing()   'false'      \n   *   isProcessing()  false   .\n   * @param - elements Array of the card elements to be added <ko>   </ko>\n   * @param - The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>     .    .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.append([HTMLElement1, HTMLElement2]);\n   * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  var __proto = InfiniteGrid.prototype;\n\n  __proto.append = function (elements, groupKey) {\n    this._layout && this._insert({\n      elements: elements,\n      isAppend: true,\n      groupKey: groupKey\n    });\n    return this;\n  };\n  /**\n   * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko     . isProcessing()   'false'      \n   * @param - elements Array of the card elements to be added <ko>   </ko>\n   * @param - The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>     .    .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n   * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  __proto.prepend = function (elements, groupKey) {\n    this._layout && this._insert({\n      elements: elements,\n      isAppend: false,\n      groupKey: groupKey\n    });\n    return this;\n  };\n  /**\n   * Specifies the Layout class to use.\n   * @ko  Layout  .\n   * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko> Layout     </ko>\n   * @param {Object} options Options to apply to the Layout.<ko>Layout  </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n   *  margin: 10,\n   *  align: \"start\"\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n   *  margin: 10,\n   *  minSize: 100,\n   *  maxSize: 200\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n   *  margin: 10,\n   *  column: 2\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n   *  margin: 10,\n   *  frame: [\n   *   [1, 2],\n   *   [4, 3],\n   *  ]\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n   *  margin: 10,\n   *  aspectRatio: 1.5\n   * });\n   * var layout = new eg.InfiniteGrid.GridLayout({\n   *   margin: 10,\n   *  align: \"start\"\n   * });\n   * infinitegrid.setLayout(layout);\n   */\n\n\n  __proto.setLayout = function (LayoutKlass, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var horizontal = this.options.horizontal;\n\n    if (typeof LayoutKlass === \"function\") {\n      this._layout = new LayoutKlass(assign(options, {\n        horizontal: horizontal\n      }));\n    } else {\n      LayoutKlass.options.horizontal = horizontal;\n      this._layout = LayoutKlass;\n    }\n\n    this._renderManager.setLayout(this._layout);\n\n    this._renderer.resize();\n\n    this._setSize(this._renderer.getViewportSize());\n\n    return this;\n  };\n  /**\n   * Returns the layouted items.\n   * @ko   .\n   * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>    .</ko>\n   * @returns List of items <ko> </ko>\n   */\n\n\n  __proto.getItems = function (includeCached) {\n    if (includeCached === void 0) {\n      includeCached = false;\n    }\n\n    return includeCached ? this._itemManager.pluck(\"items\") : this._infinite.getVisibleItems();\n  };\n  /**\n   * @param - Get items to render on screen.\n   * @ko    .\n   * @private\n   * @param - The groups currently being added by request.<ko>    .</ko>\n   * @return - The items to be rendered on screen. <ko>  .</ko>\n   */\n\n\n  __proto.getRenderingItems = function () {\n    var items = this.getItems();\n    var itemKeys = {};\n    items.forEach(function (item) {\n      itemKeys[item.itemKey] = true;\n    });\n    var nextVisisbleItems = ItemManager.pluck(this._requestGroups, \"items\").filter(function (item) {\n      if (itemKeys[item.itemKey]) {\n        return false;\n      }\n\n      itemKeys[item.itemKey] = true;\n      return true;\n    });\n    return items.concat(nextVisisbleItems);\n  };\n  /**\n   * Synchronize info of items with info given by external rendering.\n   * @ko       .\n   * @private\n   * @param - all item infos to synchronize <ko>   .</ko>\n   */\n\n\n  __proto.beforeSync = function (items) {\n    return this._infinite.sync(items);\n  };\n  /**\n   * Synchronize info of items with DOM info given by external rendering.\n   * @ko      DOM      .\n   * @private\n   * @param - The DOM elements that are currently visible.<ko>   DOM .</ko>\n   * @param - The groups currently being added by request.<ko>    .</ko>\n   */\n\n\n  __proto.sync = function (elements) {\n    var _this = this;\n\n    var itemManager = this._itemManager;\n    var infinite = this._infinite;\n    var items = this.getRenderingItems();\n    items.forEach(function (item, i) {\n      var isChange = item.el !== elements[i];\n      item.el = elements[i];\n\n      if (isChange) {\n        _this._renderer.renderItem(item, item.rect);\n      }\n    });\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    var newItems = items.filter(function (item) {\n      return item.needUpdate || !item.orgSize || !item.orgSize.width;\n    });\n\n    if (newItems.length) {\n      this._postLayout({\n        fromCache: false,\n        groups: infinite.getVisibleData(),\n        newItems: newItems,\n        isAppend: true,\n        isTrusted: false\n      });\n    } else {\n      var size = itemManager.size();\n\n      if (!size) {\n        this._requestAppend({});\n      } else if (infinite.getCursor(\"start\") < 0) {\n        var firstGroup = itemManager.getGroup(0);\n\n        this._postLayout({\n          groups: [firstGroup],\n          hasChildren: false,\n          fromCache: false,\n          isAppend: true\n        });\n      } else {\n        this._infinite.scroll(this._watcher.getScrollPos());\n      }\n    }\n  };\n  /**\n   * Rearranges a layout.\n   * @ko   .\n   * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>   </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  __proto.layout = function (isRelayout) {\n    if (isRelayout === void 0) {\n      isRelayout = true;\n    }\n\n    if (!this._layout) {\n      return this;\n    }\n\n    var renderer = this._renderer;\n    var itemManager = this._itemManager;\n    var infinite = this._infinite;\n    var isResize = renderer.resize();\n    var visibleItems = this.getItems();\n    var _a = this.options,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize,\n        transitionDuration = _a.transitionDuration;\n    var isLayoutAll = isRelayout && (isEqualSize || isConstantSize);\n\n    this._watcher.resize();\n\n    if (isRelayout) {\n      this._setSize(renderer.getViewportSize());\n    } // first layout (startCursor -1 endCursor -1)\n\n\n    if (!visibleItems.length) {\n      return this._firstLayout();\n    } // layout datas\n\n\n    var _b = infinite.getCursors(),\n        startCursor = _b[0],\n        endCursor = _b[1];\n\n    var data = isLayoutAll || !(isRelayout && isResize) ? itemManager.getGroups() : itemManager.sliceGroups(startCursor, endCursor + 1); // LayoutManger interface\n\n    this._relayout(isRelayout, data, isResize ? visibleItems : []);\n\n    if (isLayoutAll) {\n      this._fit();\n    } else if (isRelayout && isResize) {\n      itemManager.clearOutlines(startCursor, endCursor);\n    }\n\n    this._renderer.renderItems(visibleItems, transitionDuration);\n\n    isRelayout && this._watcher.setScrollPos();\n\n    this._onLayoutComplete({\n      items: visibleItems,\n      isAppend: true,\n      fromCache: true,\n      isTrusted: false,\n      useRecycle: false,\n      isLayout: true\n    });\n\n    return this;\n  };\n  /**\n   * Removes a item corresponding to an index on a grid layout.\n   * @ko      .\n   * @param - Index of group corresponding to item to remove <ko>    </ko>\n   * @param - Index of item to remove on group <ko>   </ko>\n   * @return {Object}  Removed items information <ko>  </ko>\n   */\n\n\n  __proto.removeByIndex = function (groupIndex, itemIndex, isLayout) {\n    if (isLayout === void 0) {\n      isLayout = true;\n    }\n\n    var _a = this._infinite.remove(groupIndex, itemIndex),\n        items = _a.items,\n        group = _a.group;\n\n    items.forEach(function (item) {\n      DOMRenderer.removeElement(item.el);\n    });\n\n    if (items.length) {\n      isLayout && this.layout(!!group);\n      return items;\n    }\n\n    return [];\n  };\n  /**\n   * Removes a item element on a grid layout.\n   * @ko     .\n   * @param {HTMLElement} item element to be removed <ko>  </ko>\n   * @return {Object}  Removed items information <ko>  </ko>\n   */\n\n\n  __proto.remove = function (element, isLayout) {\n    if (isLayout === void 0) {\n      isLayout = true;\n    }\n\n    var _a = this._itemManager.indexesOfElement(element),\n        groupIndex = _a.groupIndex,\n        itemIndex = _a.itemIndex;\n\n    return this.removeByIndex(groupIndex, itemIndex, isLayout);\n  };\n  /**\n   * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n   * @ko         .         append()  prepend()      . append()  prepend()        .\n   * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>    .</ko>\n   * @return {Array} List of group keys <ko>  </ko>\n   */\n\n\n  __proto.getGroupKeys = function (includeCached) {\n    var data = includeCached ? this._itemManager.getGroups() : this._infinite.getVisibleData();\n    return data.map(function (v) {\n      return v.groupKey;\n    });\n  };\n  /**\n   * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n   * @ko         .       setStatus()    \n   * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid   </ko>\n   */\n\n\n  __proto.getStatus = function (startKey, endKey) {\n    return {\n      _status: assign({}, this._status),\n      _itemManager: this._itemManager.getStatus(startKey, endKey),\n      _renderer: this._renderer.getStatus(),\n      _watcher: this._watcher.getStatus(),\n      _infinite: this._infinite.getStatus(startKey, endKey)\n    };\n  };\n  /**\n   * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n   * @ko getStatue()    eg.InfiniteGrid   .\n   * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n   * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>   .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  __proto.setStatus = function (status, applyScrollPos, syncElements) {\n    if (applyScrollPos === void 0) {\n      applyScrollPos = true;\n    }\n\n    if (!status) {\n      return this;\n    }\n\n    var _status = status._status,\n        _renderer = status._renderer,\n        _itemManager = status._itemManager,\n        _watcher = status._watcher,\n        _infinite = status._infinite;\n\n    if (!_status || !_renderer || !_itemManager || !_watcher || !_infinite) {\n      return this;\n    }\n\n    var renderExternal = this.options.renderExternal;\n    var items = this._itemManager;\n    var renderer = this._renderer;\n    var watcher = this._watcher;\n    var infinite = this._infinite;\n    watcher.detachEvent();\n    assign(this._status, _status);\n    this._status.processingStatus = IDLE;\n    items.setStatus(_itemManager);\n    renderer.setStatus(_renderer);\n    infinite.setStatus(_infinite);\n    var visibleItems = this.getItems();\n    var length = visibleItems.length;\n\n    if (renderExternal) {\n      visibleItems.forEach(function (item, i) {\n        item.el = syncElements[i];\n      });\n\n      this._renderer.renderItems(visibleItems);\n    } else {\n      renderer.createAndInsert(visibleItems, true);\n    }\n\n    var isReLayout = renderer.isNeededResize();\n    watcher.setStatus(_watcher, applyScrollPos);\n    watcher.attachEvent();\n    var _a = this.options,\n        isConstantSize = _a.isConstantSize,\n        isEqualSize = _a.isEqualSize;\n\n    if (!length) {\n      this._requestAppend({\n        cache: []\n      });\n    } else if (isReLayout) {\n      renderer.resize();\n\n      this._setSize(renderer.getViewportSize());\n\n      if (isConstantSize) {\n        this.layout(true);\n      } else {\n        this._itemManager.clearOutlines();\n\n        this._postLayout({\n          fromCache: true,\n          groups: isEqualSize ? items.getGroups() : infinite.getVisibleData(),\n          items: visibleItems,\n          newItems: visibleItems,\n          isAppend: true,\n          isTrusted: false\n        });\n      }\n    } else {\n      this.layout(false);\n    }\n\n    return this;\n  };\n  /**\n   * Clears added card elements and data.\n   * @ko      .\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  __proto.clear = function () {\n    this._itemManager.clear();\n\n    this._renderer.clear();\n\n    this._infinite.clear();\n\n    this._reset();\n\n    this._appendLoadingBar();\n\n    return this;\n  };\n  /**\n   * Specifies the Loading Bar to use for append or prepend items.\n   * @ko  append  prepend      .\n   * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko>   HTML  element  selector </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  __proto.setLoadingBar = function (userLoadingBar) {\n    if (userLoadingBar === void 0) {\n      userLoadingBar = {};\n    }\n\n    var loadingBarObj = typeof userLoadingBar === \"object\" ? userLoadingBar : {\n      append: userLoadingBar,\n      prepend: userLoadingBar\n    };\n    this._status.loadingSize = 0;\n    this._status.loadingStyle = {};\n    var loadingBar = this._loadingBar;\n    var isChangeLoadingBar = false;\n\n    for (var type in loadingBarObj) {\n      var loadingElement = $(loadingBarObj[type]);\n\n      if (loadingBar[type] !== loadingElement) {\n        loadingBar[type] = loadingElement;\n        isChangeLoadingBar = true;\n      }\n\n      if (!hasClass(loadingElement, IGNORE_CLASSNAME)) {\n        addClass(loadingElement, IGNORE_CLASSNAME);\n      }\n    }\n\n    if (isChangeLoadingBar) {\n      this._renderLoading();\n    }\n\n    this._appendLoadingBar();\n\n    return this;\n  };\n  /**\n   * Checks whether a card element or data is being added.\n   * @ko         \n   * @return {Boolean} Indicates whether a card element or data is being added <ko>        </ko>\n   */\n\n\n  __proto.isProcessing = function () {\n    return this._isProcessing() || this.isLoading();\n  };\n  /**\n   * Checks whether data is loading.\n   * @ko    \n   * @return {Boolean} Indicates whether data is loading <ko>    </ko>\n   */\n\n\n  __proto.isLoading = function () {\n    return this._getLoadingStatus() > 0;\n  };\n  /**\n   * Returns the element of loading bar.\n   * @ko   element .\n   * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n   * @return {Element} The element of loading bar. <ko>  element</ko>\n   */\n\n\n  __proto.getLoadingBar = function (isAppend) {\n    if (isAppend === void 0) {\n      isAppend = this._getLoadingStatus() !== LOADING_PREPEND;\n    }\n\n    return this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n  };\n  /**\n   * Start loading for append/prepend during loading data.\n   * @ko    append/prepend   .\n   * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n   * @param {Object} [userStyle = {display: \"block\"}] custom style to apply to this loading bar for start. <ko>         </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  __proto.startLoading = function (isAppend, userStyle) {\n    var _this = this;\n\n    if (userStyle === void 0) {\n      userStyle = {\n        display: \"block\"\n      };\n    }\n\n    if (this.isLoading()) {\n      return this;\n    }\n\n    var type = isAppend ? \"append\" : \"prepend\";\n\n    this._process(isAppend ? LOADING_APPEND : LOADING_PREPEND);\n\n    if (!this._loadingBar[type]) {\n      return this;\n    }\n\n    var next = function next() {\n      _this._renderLoading(userStyle);\n\n      _this._status.loadingStyle = userStyle;\n\n      if (!isAppend) {\n        _this._fit();\n      } else {\n        _this._setContainerSize(_this._getEdgeValue(\"end\") + _this._status.loadingSize);\n      }\n    };\n\n    if (this.options.renderExternal) {\n      this.trigger(\"render\", {\n        next: next\n      });\n    } else {\n      next();\n    }\n\n    return this;\n  };\n  /**\n   * End loading after startLoading() for append/prepend\n   * @ko  append/prepend  startLoading()    .\n   * @param {Object} [userStyle = {display: \"none\"}] custom style to apply to this loading bar for end <ko>         </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  __proto.endLoading = function (userStyle) {\n    var _a;\n\n    if (userStyle === void 0) {\n      userStyle = {\n        display: \"none\"\n      };\n    }\n\n    if (!this.isLoading()) {\n      return this;\n    }\n\n    var isAppend = this._getLoadingStatus() === LOADING_APPEND;\n    var type = isAppend ? \"append\" : \"prepend\";\n    var el = this._loadingBar[type];\n    var status = this._status;\n    var size = status.loadingSize;\n\n    this._process(LOADING_APPEND | LOADING_PREPEND, false);\n\n    status.loadingSize = 0;\n    status.loadingStyle = {};\n\n    if (el) {\n      var style = assign((_a = {}, _a[this.options.horizontal ? \"left\" : \"top\"] = -size + \"px\", _a), userStyle);\n\n      for (var property in style) {\n        el.style[property] = style[property];\n      }\n\n      if (!isAppend) {\n        this._fitItems(size);\n      } else {\n        this._setContainerSize(this._getEdgeValue(\"end\"));\n      }\n\n      if (this.options.renderExternal) {\n        this.trigger(\"render\", {\n          next: function next() {}\n        });\n      }\n    }\n\n    if (this.options.useRecycle && !this.isProcessing()) {\n      this._infinite.recycle(this._watcher.getScrollPos(), isAppend);\n    }\n\n    return this;\n  };\n  /**\n   * Retrieves the item via index or the element.\n   * @ko index  element   .\n   * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item  element   item  group index</ko>\n   * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex    group  Item index </ko>\n   * @return The item containing the content, size and position,etc<ko>content, size, position   item </ko>\n   * @example\n    ig.getItem(0, 0);\n   ig.getItem(element);\n    {\n    el: HTMLElement,\n    content: \"<div>...</div>\",\n    size: {width: ..., height: ...},\n    rect: {top: ..., left: ..., width: ..., height: ...},\n   }\n   */\n\n\n  __proto.getItem = function (groupIndex, itemIndex) {\n    if (groupIndex === void 0) {\n      groupIndex = 0;\n    }\n\n    if (typeof groupIndex === \"object\") {\n      if (!groupIndex) {\n        return;\n      }\n\n      var items = this.getItems();\n      var length = items.length;\n\n      for (var i = 0; i < length; ++i) {\n        if (items[i].el === groupIndex) {\n          return items[i];\n        }\n      }\n\n      return undefined;\n    } else {\n      var group = this._itemManager.getGroup(groupIndex);\n\n      return group && group.items[itemIndex || 0];\n    }\n  };\n  /**\n   * Updates the item via index or the element.\n   * @ko index  element   .\n   * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item  element   item  group index</ko>\n   * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex    group  Item index </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n  element.innerHTML = \"2\";\n  element.style.height = \"400px\";\n  ig.updateItem(element);\n  ig.updateItem(0, 0);\n   */\n\n\n  __proto.updateItem = function (groupIndex, itemIndex) {\n    var item = this.getItem(groupIndex, itemIndex);\n    this._updateItem(item) && this.layout(false);\n    return this;\n  };\n  /**\n   * Update the currently displayed items.\n   * @ko   .\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n  element.innerHTML = \"2\";\n  element.style.height = \"400px\";\n   element2.innerHTML = \"2\";\n  element2.style.height = \"400px\";\n   ig.updateItems();\n   */\n\n\n  __proto.updateItems = function () {\n    var _this = this;\n\n    this.getItems().forEach(function (item) {\n      _this._updateItem(item);\n    });\n    this.layout(false);\n    return this;\n  };\n  /**\n   * Move to some group or item position.\n   * @ko      .\n   * @param {Number} [index] group's index <ko>  index</ko>\n   * @param {Number} [itemIndex=-1] item's index <ko>  index</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  __proto.moveTo = function (index, itemIndex) {\n    var _this = this;\n\n    if (itemIndex === void 0) {\n      itemIndex = 0;\n    }\n\n    if (this.isProcessing()) {\n      return this;\n    }\n\n    var data = this._itemManager.getGroup(index);\n\n    if (!data) {\n      return this;\n    }\n\n    var infinite = this._infinite;\n    var outlines = data.outlines;\n    var items = data.items;\n    var item = items[itemIndex];\n    var isResize = outlines.start && outlines.start.length === 0;\n\n    var _a = infinite.getCursors(),\n        startCursor = _a[0],\n        endCursor = _a[1];\n\n    var isInCursor = startCursor <= index && index <= endCursor;\n    var _b = this.options,\n        useRecycle = _b.useRecycle,\n        horizontal = _b.horizontal;\n\n    if (isInCursor || !useRecycle || !isResize) {\n      var pos = item ? item.rect[horizontal ? \"left\" : \"top\"] : Math.max.apply(Math, outlines.start);\n      var fit = Math.min.apply(Math, outlines.start);\n\n      if (fit < 0) {\n        // base < 0\n        this._fitItems(fit, 0);\n\n        pos -= fit;\n      }\n\n      var isAppend = index > startCursor;\n\n      if (isInCursor || isAppend) {\n        this._scrollTo(pos);\n\n        return this;\n      }\n\n      this._postLayout({\n        fromCache: true,\n        groups: [data],\n        items: items,\n        newItems: [],\n        isAppend: isAppend,\n        isTrusted: false\n      }).on(\"renderComplete\", function (_a) {\n        var start = _a.start,\n            end = _a.end;\n        var itemManager = _this._itemManager;\n\n        if (!itemManager) {\n          return;\n        }\n\n        var scrollPos = items[itemIndex].rect[horizontal ? \"left\" : \"top\"];\n\n        if (!isInCursor) {\n          itemManager.clearOutlines(start, end);\n        }\n\n        _this._scrollTo(scrollPos);\n\n        _this._setScrollPos(scrollPos);\n      });\n\n      return this;\n    } else {\n      var isAppend = index > endCursor || index < startCursor - 1;\n\n      this._postCache({\n        isAppend: isAppend,\n        cache: [data],\n        isTrusted: false\n      }).on(\"renderComplete\", function (_a) {\n        var start = _a.start,\n            end = _a.end;\n        var itemManager = _this._itemManager;\n\n        if (!itemManager) {\n          return;\n        }\n\n        var pos = items[itemIndex].rect[horizontal ? \"left\" : \"top\"];\n        itemManager.clearOutlines(start, end);\n\n        _this._scrollTo(pos);\n\n        _this._setScrollPos(pos);\n      });\n    }\n\n    return this;\n  };\n  /**\n  * Destroys elements, properties, and events used on a grid layout.\n  * @ko     ,  \n  */\n\n\n  __proto.destroy = function () {\n    this._infinite.clear();\n\n    this._watcher.destroy();\n\n    this._reset();\n\n    this._itemManager.clear();\n\n    this._renderer.destroy();\n\n    this._renderManager.destroy();\n  };\n\n  __proto._relayout = function (isRelayout, groups, items) {\n    var renderer = this._renderer;\n    var _a = renderer.options,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize;\n    var layoutGroups = groups.filter(function (group) {\n      var item = group.items[0];\n      return item.orgSize && item.rect.top > DUMMY_POSITION / 10;\n    });\n\n    if (!layoutGroups.length) {\n      return [];\n    }\n\n    var outline = layoutGroups[0].outlines.start;\n\n    if (isRelayout) {\n      outline = [outline.length ? Math.min.apply(Math, outline) : 0];\n\n      if (!isConstantSize && items.length) {\n        renderer.updateSize(items); // update invisible items' size\n\n        if (isEqualSize && items[0].size) {\n          ItemManager.pluck(layoutGroups, \"items\").forEach(function (item) {\n            item.size = assign({}, items[0].size);\n          });\n        }\n      }\n    }\n\n    this._layout.layout(layoutGroups, outline);\n\n    layoutGroups.forEach(function (group) {\n      group.needUpdate = false;\n    });\n  };\n\n  __proto._setContainerSize = function (size) {\n    this._renderer.setContainerSize(Math.max(this._itemManager.getMaxEdgeValue(), size));\n  };\n\n  __proto._appendLoadingBar = function () {\n    if (!this.options.renderExternal) {\n      var loadingBar = this._loadingBar;\n      var container = this._renderer.container;\n\n      for (var type in loadingBar) {\n        container.appendChild(loadingBar[type]);\n      }\n    }\n  };\n\n  __proto._setSize = function (size) {\n    this._infinite.setSize(this._renderer.getViewSize());\n\n    this._layout.setSize(size);\n  };\n\n  __proto._fitItems = function (base, margin) {\n    if (margin === void 0) {\n      margin = 0;\n    }\n\n    base > 0 && this._watcher.scrollBy(-base);\n\n    this._itemManager.fit(base, this.options.horizontal);\n\n    this._renderer.renderItems(this.getItems());\n\n    this._setContainerSize(this._getEdgeValue(\"end\") || margin);\n\n    base < 0 && this._watcher.scrollBy(-base);\n  }; // called by visible\n\n\n  __proto._fit = function (useFit) {\n    if (useFit === void 0) {\n      useFit = this.options.useFit;\n    }\n\n    var base = this._getEdgeValue(\"start\");\n\n    var margin = this._getLoadingStatus() === LOADING_PREPEND && this._status.loadingSize || 0;\n    var _a = this.options,\n        isConstantSize = _a.isConstantSize,\n        isEqualSize = _a.isEqualSize,\n        useRecycle = _a.useRecycle;\n\n    if (!useRecycle || !useFit || isConstantSize || isEqualSize) {\n      if (base < margin) {\n        this._fitItems(base - margin, margin);\n      }\n\n      base = 0;\n    } else if (base !== 0 || margin) {\n      this._fitItems(base - margin, margin);\n    } else {\n      return 0;\n    }\n\n    this.isLoading() && this._renderLoading();\n    return base;\n  };\n\n  __proto._getEdgeValue = function (cursor) {\n    return this._infinite.getEdgeValue(cursor);\n  };\n\n  __proto._isProcessing = function () {\n    return (this._status.processingStatus & PROCESSING) > 0;\n  };\n\n  __proto._getLoadingStatus = function () {\n    return this._status.processingStatus & (LOADING_APPEND | LOADING_PREPEND);\n  };\n\n  __proto._process = function (status, isAdd) {\n    if (isAdd === void 0) {\n      isAdd = true;\n    }\n\n    if (isAdd) {\n      this._status.processingStatus |= status;\n    } else {\n      this._status.processingStatus -= this._status.processingStatus & status;\n    }\n  };\n\n  __proto._insert = function (_a) {\n    var elements = _a.elements,\n        isAppend = _a.isAppend,\n        hasChildren = _a.hasChildren,\n        _b = _a.groupKey,\n        groupKey = _b === void 0 ? this._getRandomKey() : _b;\n\n    if (this._isProcessing() || elements.length === 0) {\n      return;\n    }\n\n    var items = ItemManager.toItems($(elements, true), groupKey);\n\n    this._insertItems({\n      items: items,\n      isAppend: isAppend,\n      hasChildren: hasChildren,\n      groupKey: groupKey\n    });\n  };\n\n  __proto._insertItems = function (_a) {\n    var items = _a.items,\n        isAppend = _a.isAppend,\n        hasChildren = _a.hasChildren,\n        _b = _a.groupKey,\n        groupKey = _b === void 0 ? this._getRandomKey() : _b;\n\n    if (!items.length) {\n      return;\n    }\n\n    var group = this._itemManager[isAppend ? \"appendGroup\" : \"prependGroup\"]({\n      groupKey: groupKey,\n      items: items\n    });\n\n    if (!isAppend) {\n      var infinite = this._infinite;\n\n      var _c = infinite.getCursors(),\n          startCursor = _c[0],\n          endCursor = _c[1];\n\n      infinite.setCursor(\"start\", startCursor + 1);\n      infinite.setCursor(\"end\", endCursor + 1);\n    }\n\n    this._postLayout({\n      fromCache: false,\n      groups: [group],\n      items: group.items,\n      newItems: group.items,\n      isAppend: isAppend,\n      hasChildren: hasChildren,\n      isTrusted: false\n    });\n  }; // add items, and remove items for recycling\n\n\n  __proto._recycle = function (ranges) {\n    var _this = this;\n\n    var _a = this.options,\n        useRecycle = _a.useRecycle,\n        renderExternal = _a.renderExternal;\n\n    if (!useRecycle) {\n      return false;\n    }\n\n    var isRecycle = false;\n    ranges.forEach(function (_a) {\n      var start = _a.start,\n          end = _a.end;\n\n      if (start === -1 || end === -1 || end < start) {\n        return;\n      }\n\n      var items = _this._itemManager.pluck(\"items\", start, end);\n\n      isRecycle = isRecycle || items.some(function (item) {\n        return item.mounted;\n      });\n      items.forEach(function (item) {\n        item.mounted = false;\n      });\n\n      if (!renderExternal) {\n        DOMRenderer.removeItems(items);\n      }\n    });\n\n    if (isRecycle) {\n      this._requestGroups = [];\n      this.trigger(\"render\", {\n        next: function next() {}\n      });\n    }\n\n    return isRecycle;\n  };\n\n  __proto._renderLoading = function (userStyle) {\n    if (userStyle === void 0) {\n      userStyle = this._status.loadingStyle;\n    }\n\n    if (!this.isLoading()) {\n      return;\n    }\n\n    var isAppend = this._getLoadingStatus() === LOADING_APPEND;\n    var el = this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\n    if (!el) {\n      return;\n    }\n\n    var style = assign({\n      position: \"absolute\"\n    }, userStyle);\n\n    for (var property in style) {\n      el.style[property] = style[property];\n    }\n\n    var _a = this.options,\n        useOffset = _a.useOffset,\n        horizontal = _a.horizontal;\n\n    if (horizontal) {\n      this._status.loadingSize = useOffset ? getOffsetWidth(el) : getRectWidth(el);\n    } else {\n      this._status.loadingSize = useOffset ? getOffsetHeight(el) : getRectHeight(el);\n    }\n\n    var posName = this.options.horizontal ? \"left\" : \"top\";\n\n    if (!(posName in style)) {\n      var pos = isAppend ? this._getEdgeValue(\"end\") : this._getEdgeValue(\"start\") - this._status.loadingSize;\n      el.style[posName] = pos + \"px\";\n    }\n  };\n\n  __proto._updateItem = function (item) {\n    if (item && item.el) {\n      item.content = item.el.outerHTML;\n      !this.options.isEqualSize && resetSize(item);\n\n      this._renderer.updateSize([item]);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  __proto._setScrollPos = function (pos) {\n    this._watcher.setScrollPos(this._watcher.getContainerOffset() + pos);\n  };\n\n  __proto._scrollTo = function (pos) {\n    this._watcher.scrollTo(this._watcher.getContainerOffset() + pos);\n  };\n\n  __proto._postCache = function (_a) {\n    var cache = _a.cache,\n        isAppend = _a.isAppend,\n        _b = _a.isTrusted,\n        isTrusted = _b === void 0 ? true : _b;\n    var isConstantSize = this.options.isConstantSize;\n    var items = ItemManager.pluck(cache, \"items\");\n    var fromCache = true;\n    var newItems = items.filter(function (item) {\n      if (!item.orgSize || !item.orgSize.width) {\n        fromCache = false;\n        return true;\n      }\n\n      return !isConstantSize && item.rect.top < DUMMY_POSITION / 10;\n    });\n    return this._postLayout({\n      fromCache: fromCache,\n      groups: cache,\n      items: items,\n      newItems: newItems,\n      isAppend: isAppend,\n      isTrusted: isTrusted\n    });\n  };\n\n  __proto._postLayout = function (_a) {\n    var _this = this;\n\n    var fromCache = _a.fromCache,\n        groups = _a.groups,\n        _b = _a.items,\n        items = _b === void 0 ? ItemManager.pluck(groups, \"items\") : _b,\n        newItems = _a.newItems,\n        isAppend = _a.isAppend,\n        hasChildren = _a.hasChildren,\n        isTrusted = _a.isTrusted;\n\n    this._process(PROCESSING);\n\n    if (!groups.length) {\n      return;\n    }\n\n    var renderExternal = this.options.renderExternal;\n    var renderer = this._renderer;\n    var callbackComponent = new Component();\n\n    var _next = function next() {\n      items.forEach(function (item) {\n        item.mounted = true;\n      });\n\n      _this._renderManager.render(callbackComponent, groups, newItems, isAppend).on(\"imageError\", function (e) {\n        /**\n         * This event is fired when an error occurs in the image.\n         * @ko       .\n         * @event eg.InfiniteGrid#imageError\n         * @param {eg.InfiniteGrid.IErrorCallbackOptions} e - The object of data to be sent to an event <ko>   </ko>\n         * @param {HTMLElement} [e.element] - Appending card's image element.<ko>    </ko>\n         * @param {target} [e.target] - The item's element with error images.<ko>     </ko>\n         * @param {Item[]} [e.items] - The items being added.<ko>  </ko>\n         * @param {Item} [e.item] - The item with error images.<ko>    </ko>\n         * @param {number} [e.index]  - The item's index with error images.<ko>     </ko>\n         * @param {number} [e.totalIndex] - The item's index with error images in all items.<ko>       </ko>\n         * @param {function} [e.remove] - In the imageError event, this method expects to remove the error image.<ko>       .</ko>\n         * @param {function} [e.removeItem] - In the imageError event, this method expects to remove the item with the error image.<ko>          .</ko>\n         * @param {function} [e.replace] - In the imageError event, this method expects to replace the error image's source or element.<ko>          .</ko>\n         * @param {function} [e.replaceItem] - In the imageError event, this method expects to replace the item's contents with the error image.<ko>           .</ko>\n         * @example\n        ig.on(\"imageError\", e => {\n            e.remove();\n            e.removeItem();\n            e.replace(\"http://...jpg\");\n            e.replace(imageElement);\n            e.replaceItem(\"item html\");\n        });\n        */\n        _this.trigger(\"imageError\", e);\n      }).on(\"contentError\", function (e) {\n        /**\n         * This event is fired when an error occurs in the content.\n         * @ko       .\n         * @event eg.InfiniteGrid#contentError\n         * @param {eg.InfiniteGrid.IErrorCallbackOptions} e - The object of data to be sent to an event <ko>   </ko>\n         * @param {HTMLElement} [e.element] - Appending card's image element.<ko>    </ko>\n         * @param {target} [e.target] - The item's element with error images.<ko>     </ko>\n         * @param {Item[]} [e.items] - The items being added.<ko>  </ko>\n         * @param {Item} [e.item] - The item with error images.<ko>    </ko>\n         * @param {number} [e.index]  - The item's index with error images.<ko>     </ko>\n         * @param {number} [e.totalIndex] - The item's index with error images in all items.<ko>       </ko>\n         * @param {function} [e.remove] - In the contentError event, this method expects to remove the error image.<ko>       .</ko>\n         * @param {function} [e.removeItem] - In the contentError event, this method expects to remove the item with the error image.<ko>          .</ko>\n         * @param {function} [e.replace] - In the contentError event, this method expects to replace the error image's source or element. If the replacement was done externally, call replace().<ko>       .    replace() .</ko>\n         * @param {function} [e.replaceItem] - In the contentError event, this method expects to replace the item's contents with the error image.<ko>           .</ko>\n         * @example\n        ig.on(\"contentError\", e => {\n            e.remove();\n            e.removeItem();\n            e.replace(imageElement);\n            // If the replacement was done externally\n            e.replace();\n            e.replaceItem(\"item html\");\n        });\n        */\n        _this.trigger(\"contentError\", e);\n      }).on(\"renderComplete\", function (_a) {\n        var start = _a.start,\n            end = _a.end;\n\n        _this._setCursor(start, end);\n      }).on(\"layoutComplete\", function (_a) {\n        var layoutItems = _a.items;\n\n        _this._process(PROCESSING, false);\n\n        _this._onLayoutComplete({\n          items: layoutItems,\n          isAppend: isAppend,\n          fromCache: fromCache,\n          isTrusted: isTrusted,\n          useRecycle: false\n        });\n      }).on(\"readyElement\", function (e) {\n        _this._updateItem(e.item) && _this.layout(false);\n      }).on(\"ready\", function (_a) {\n        var remove = _a.remove,\n            layout = _a.layout;\n        remove.forEach(function (el) {\n          return _this.remove(el, false);\n        });\n\n        if (layout) {\n          _this.layout(false);\n        } else if (!_this.isProcessing() && _this.options.useRecycle) {\n          var scroller = _this._watcher;\n          var scrollPos = scroller.getScrollPos();\n\n          _this._infinite.recycle(scrollPos, isAppend);\n        }\n      });\n    };\n\n    if (!hasChildren) {\n      if (renderExternal) {\n        if (items.every(function (item) {\n          return item.mounted;\n        })) {\n          _next();\n        } else {\n          this._requestGroups = groups;\n          this.trigger(\"render\", {\n            next: function next() {\n              !hasChildren && _this._renderer.renderItems(items);\n\n              _next();\n            }\n          });\n        }\n\n        return callbackComponent;\n      } else {\n        // If container has children, it does not render first.\n        renderer.createAndInsert(items, isAppend);\n      }\n    }\n\n    _next();\n\n    return callbackComponent;\n  }; // called by visible\n\n\n  __proto._requestAppend = function (_a) {\n    var _this = this;\n\n    var cache = _a.cache;\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache: cache,\n        isAppend: true\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n       * @ko          .          \n       * @event eg.InfiniteGrid#append\n       * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n       * @param {Function} param.startLoading Start loading for append loading data. <ko>     . </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       */\n      this.trigger(\"append\", {\n        isTrusted: true,\n        groupKey: this.getGroupKeys().pop() || \"\",\n        startLoading: function startLoading(userStyle) {\n          _this.startLoading(true, userStyle);\n        },\n        endLoading: function endLoading(userStyle) {\n          _this.endLoading(userStyle);\n        }\n      });\n    }\n  }; // called by visible\n\n\n  __proto._requestPrepend = function (_a) {\n    var _this = this;\n\n    var cache = _a.cache;\n\n    this._fit(this.options.useFit || !cache || !cache.length);\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache: cache,\n        isAppend: false\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n       * @ko         .          .\n       * @event eg.InfiniteGrid#prepend\n       * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n       * @param {Function} param.startLoading Start loading for prepend loading data. <ko>     . </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       */\n      this.trigger(\"prepend\", {\n        isTrusted: true,\n        groupKey: this.getGroupKeys().shift(),\n        startLoading: function startLoading(userStyle) {\n          _this.startLoading(false, userStyle);\n        },\n        endLoading: function endLoading(userStyle) {\n          _this.endLoading(userStyle);\n        }\n      });\n    }\n  };\n\n  __proto._onResize = function () {\n    this.layout(true);\n  };\n\n  __proto._setCursor = function (start, end) {\n    var infinite = this._infinite;\n\n    var _a = infinite.getCursors(),\n        startCursor = _a[0],\n        endCursor = _a[1];\n\n    infinite.setCursor(\"start\", start);\n    infinite.setCursor(\"end\", end);\n\n    var isRecycle = this._recycle([{\n      start: startCursor,\n      end: start - 1\n    }, {\n      start: end + 1,\n      end: endCursor\n    }]);\n\n    if (!isRecycle) {\n      this._requestGroups = [];\n      this.trigger(\"render\", {\n        next: function next() {}\n      });\n    }\n  };\n\n  __proto._onCheck = function (_a) {\n    var isForward = _a.isForward,\n        scrollPos = _a.scrollPos,\n        horizontal = _a.horizontal,\n        orgScrollPos = _a.orgScrollPos;\n    /**\n     * This event is fired when the user scrolls.\n     * @ko      .\n     * @event eg.InfiniteGrid#change\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>    ,   .</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n     * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>  </ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n     * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false </ko>\n     */\n\n    this.trigger(\"change\", {\n      isForward: isForward,\n      horizontal: horizontal,\n      scrollPos: scrollPos,\n      orgScrollPos: orgScrollPos\n    });\n\n    this._infinite.scroll(scrollPos);\n  };\n\n  __proto._onLayoutComplete = function (_a) {\n    var _this = this;\n\n    var items = _a.items,\n        isAppend = _a.isAppend,\n        _b = _a.isTrusted,\n        isTrusted = _b === void 0 ? false : _b,\n        _c = _a.useRecycle,\n        useRecycle = _c === void 0 ? this.options.useRecycle : _c,\n        _d = _a.fromCache,\n        fromCache = _d === void 0 ? false : _d,\n        _e = _a.isLayout,\n        isLayout = _e === void 0 ? false : _e;\n\n    var viewSize = this._renderer.getViewSize();\n\n    if (!isAppend) {\n      this._fit();\n    } else {\n      this.isLoading() && this._renderLoading();\n    }\n\n    var watcher = this._watcher;\n    var scrollPos = watcher.getScrollPos(); // recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\n    if (!isLayout && useRecycle && !this.isLoading()) {\n      this._infinite.recycle(scrollPos, isAppend);\n    }\n\n    var size = this._getEdgeValue(\"end\");\n\n    if (isAppend) {\n      this._setContainerSize(size + this._status.loadingSize || 0);\n\n      if (typeof scrollPos === \"number\" && scrollPos > 0) {\n        !IS_IOS && this._scrollTo(scrollPos);\n      }\n    }\n    /**\n     * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n     * @ko      . append()  prepend() , layout()        \n     * @event eg.InfiniteGrid#layoutComplete\n     *\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Array} param.target Rearranged card elements<ko>  </ko>\n     * @param {Boolean} param.fromCache Check whether these items are cache or not <ko>    .</ko>\n     * @param {Boolean} param.isLayout Returns true if this is an event called by resize event or layout method. Returns false if this is an event called by adding an item. <ko>     layout()    true,    false .</ko>\n     * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>  append()   . layout()    layoutComplete   'true' .</ko>\n     * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called <ko>append, prend      .</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n     * @param {Number} param.orgScrollPos Current position of the scroll <ko>  </ko>\n     * @param {Number} param.size The size of container element <ko>  </ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n     * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n     * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n     */\n\n\n    this.trigger(\"layoutComplete\", {\n      target: items.concat(),\n      isAppend: !!isAppend,\n      isTrusted: isTrusted,\n      fromCache: fromCache,\n      isLayout: isLayout,\n      isScroll: viewSize < watcher.getContainerOffset() + size,\n      scrollPos: scrollPos,\n      orgScrollPos: watcher.getOrgScrollPos(),\n      size: size,\n      endLoading: function endLoading(userStyle) {\n        _this.endLoading(userStyle);\n      }\n    });\n\n    this._infinite.scroll(scrollPos);\n  };\n\n  __proto._firstLayout = function () {\n    var renderer = this._renderer;\n    var infinite = this._infinite;\n    var itemManager = this._itemManager;\n    var attributePrefix = this.options.attributePrefix;\n    var children = toArray(renderer.container.children).filter(function (el) {\n      return el.className.indexOf(IGNORE_CLASSNAME) === -1;\n    });\n    var hasChildren = children.length > 0;\n\n    if (itemManager.size()) {\n      // no visible items\n      if (hasChildren) {\n        itemManager.pluck(\"items\").forEach(function (item, i) {\n          item.el = children[i];\n        });\n      }\n    } else {\n      // no items, no visible items, no elements\n      if (!hasChildren) {\n        if (renderer.getContainerSize()) {\n          renderer.setContainerSize(0);\n        }\n\n        this._requestAppend({});\n\n        return this;\n      } // no items, no visible items\n\n\n      var prevGroupKey_1 = \"\" + this._getRandomKey();\n\n      children.forEach(function (el) {\n        var groupKey = el.getAttribute(attributePrefix + \"groupkey\");\n\n        if (typeof groupKey !== \"string\") {\n          groupKey = prevGroupKey_1;\n        }\n\n        prevGroupKey_1 = groupKey;\n        itemManager.insert({\n          groupKey: groupKey,\n          el: el\n        });\n      });\n    } // The currently displayed elements are visible groups.\n\n\n    var groups = itemManager.getGroups();\n    infinite.setCursor(\"start\", 0);\n    infinite.setCursor(\"end\", groups.length - 1);\n\n    this._postLayout({\n      groups: groups,\n      hasChildren: hasChildren,\n      fromCache: false,\n      isAppend: true\n    });\n\n    return this;\n  };\n\n  __proto._getRandomKey = function () {\n    var itemManager = this._itemManager;\n\n    while (true) {\n      var groupKey = new Date().getTime() + Math.floor(Math.random() * 1000);\n\n      if (!itemManager.getGroupByKey(groupKey)) {\n        return groupKey;\n      }\n    }\n  };\n\n  __proto._reset = function () {\n    this._status = {\n      processingStatus: IDLE,\n      loadingSize: 0,\n      loadingStyle: {}\n    };\n  };\n  /**\n   * Version info string\n   * @ko  \n   * @name VERSION\n   * @static\n   * @type {String}\n   * @example\n   * eg.InfiniteGrid.VERSION;  // ex) 3.3.3\n   * @memberof eg.InfiniteGrid\n   */\n\n\n  InfiniteGrid.VERSION = \"3.9.0\";\n  return InfiniteGrid;\n}(Component);\n\nvar START = ALIGN.START,\n    CENTER = ALIGN.CENTER,\n    END = ALIGN.END,\n    JUSTIFY = ALIGN.JUSTIFY;\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout          .      ,        .            .\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>   (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n  margin: 10,\n  align: \"start\",\n  itemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n  margin: 10,\n  align: \"center\",\n  itemSize: 200,\n  horizontal: true,\n});\n\n</script>\n```\n **/\n\nvar GridLayout = /*#__PURE__*/function () {\n  function GridLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      align: START,\n      itemSize: 0\n    }, options);\n    this._size = 0;\n    this._columnSize = 0;\n    this._columnLength = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  var __proto = GridLayout.prototype;\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.GridLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  __proto.layout = function (groups, outline) {\n    var _this = this;\n\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var firstItem = groups.length && groups[0].items.length && groups[0].items[0];\n    this.checkColumn(firstItem); // if outlines' length and columns' length are now same, re-caculate outlines.\n\n    var startOutline;\n\n    if (outline.length !== this._columnLength) {\n      var pos = outline.length === 0 ? 0 : Math.min.apply(Math, outline); // re-layout items.\n\n      startOutline = fill(new Array(this._columnLength), pos);\n    } else {\n      startOutline = outline.slice();\n    }\n\n    groups.forEach(function (group) {\n      var items = group.items;\n\n      var result = _this._layout(items, startOutline, true);\n\n      group.outlines = result;\n      startOutline = result.end;\n    });\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n\n  __proto.checkColumn = function (item) {\n    var _a = this.options,\n        itemSize = _a.itemSize,\n        margin = _a.margin,\n        horizontal = _a.horizontal;\n    var sizeName = horizontal ? \"height\" : \"width\";\n    var columnSize = Math.floor(itemSize || item && item.size[sizeName] || 0) || 0;\n    this._columnSize = columnSize;\n\n    if (!columnSize) {\n      this._columnLength = 1;\n      return;\n    }\n\n    this._columnLength = Math.max(Math.floor((this._size + margin) / (columnSize + margin)), 1);\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    var _a;\n\n    var length = items.length;\n    var margin = this.options.margin;\n    var align = this.options.align;\n    var style = this._style;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var pos1Name = style.startPos1;\n    var pos2Name = style.startPos2;\n    var columnSize = this._columnSize;\n    var columnLength = this._columnLength;\n    var size = this._size;\n    var viewDist = size - (columnSize + margin) * columnLength + margin;\n    var pointCaculateName = isAppend ? \"min\" : \"max\";\n    var indexCaculateName = isAppend ? \"indexOf\" : \"lastIndexOf\";\n    var startOutline = outline.slice();\n    var endOutline = outline.slice();\n\n    for (var i = 0; i < length; ++i) {\n      var point = Math[pointCaculateName].apply(Math, endOutline) || 0;\n      var index = endOutline[indexCaculateName](point);\n      var item = items[isAppend ? i : length - 1 - i];\n      var itemSize = item.size;\n\n      if (!itemSize) {\n        continue;\n      }\n\n      var size1 = itemSize[size1Name];\n      var size2 = itemSize[size2Name];\n      var pos1 = isAppend ? point : point - margin - size1;\n      var endPos1 = pos1 + size1 + margin;\n\n      if (index === -1) {\n        index = 0;\n      }\n\n      var pos2 = (columnSize + margin) * index; // ALIGN\n\n      if (align === CENTER) {\n        pos2 += viewDist / 2;\n      } else if (align === END) {\n        pos2 += viewDist + columnSize - size2;\n      } else if (align === JUSTIFY) {\n        if (columnLength <= 1) {\n          pos2 += viewDist / 2;\n        } else {\n          pos2 = (size - columnSize) / (columnLength - 1) * index;\n        }\n      } // tetris\n\n\n      item.rect = (_a = {}, _a[pos1Name] = pos1, _a[pos2Name] = pos2, _a);\n      item.column = index;\n      endOutline[index] = isAppend ? endPos1 : pos1;\n    }\n\n    if (!isAppend) {\n      items.sort(function (a, b) {\n        var item1pos1 = a.rect[pos1Name];\n        var item1pos2 = a.rect[pos2Name];\n        var item2pos1 = b.rect[pos1Name];\n        var item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    } // if append items, startOutline is low, endOutline is high\n    // if prepend items, startOutline is high, endOutline is low\n\n\n    return {\n      start: isAppend ? startOutline : endOutline,\n      end: isAppend ? endOutline : startOutline\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var clone = cache ? items : cloneItems(items);\n    var startOutline = outline;\n\n    if (!this._columnLength) {\n      this.checkColumn(items[0]);\n    }\n\n    if (outline.length !== this._columnLength) {\n      startOutline = fill(new Array(this._columnLength), outline.length ? Math[isAppend ? \"min\" : \"max\"].apply(Math, outline) || 0 : 0);\n    }\n\n    var result = this._layout(clone, startOutline, isAppend);\n\n    return {\n      items: clone,\n      outlines: result\n    };\n  };\n\n  return GridLayout;\n}();\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\n\n\nfunction disableFrame(frame, type, top, left, width, height) {\n  for (var i = top; i < top + height; ++i) {\n    for (var j = left; j < left + width; ++j) {\n      if (type !== frame[i][j]) {\n        continue;\n      }\n\n      frame[i][j] = 0;\n    }\n  }\n}\n\nfunction searchShapeInFrame(frame, type, top, left, width, height) {\n  var size = {\n    left: left,\n    top: top,\n    type: type,\n    width: 1,\n    height: 1\n  };\n\n  for (var i = left; i < width; ++i) {\n    if (frame[top][i] === type) {\n      size.width = i - left + 1;\n      continue;\n    }\n\n    break;\n  }\n\n  for (var i = top; i < height; ++i) {\n    if (frame[i][left] === type) {\n      size.height = i - top + 1;\n      continue;\n    }\n\n    break;\n  } // After finding the shape, it will not find again.\n\n\n  disableFrame(frame, type, top, left, size.width, size.height);\n  return size;\n}\n\nfunction getShapes(frame) {\n  var height = frame.length;\n  var width = height ? frame[0].length : 0;\n  var shapes = [];\n\n  for (var i = 0; i < height; ++i) {\n    for (var j = 0; j < width; ++j) {\n      var type = frame[i][j];\n\n      if (!type) {\n        continue;\n      } // Separate shapes with other numbers.\n\n\n      shapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n    }\n  }\n\n  shapes.sort(function (a, b) {\n    return a.type < b.type ? -1 : 1;\n  });\n  return {\n    shapes: shapes,\n    width: width,\n    height: height\n  };\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout      .             .\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko>          . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n  margin: 10,\n  itemSize: 200,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n  margin: 10,\n  itemSize: 200,\n  horizontal: true,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n</script>\n```\n **/\n\n\nvar FrameLayout = /*#__PURE__*/function () {\n  function FrameLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      itemSize: 0,\n      frame: [],\n      frameFill: true\n    }, options);\n    var frame = this.options.frame.map(function (row) {\n      return row.slice();\n    });\n    this._itemSize = this.options.itemSize || 0; // divide frame into shapes.\n\n    this._shapes = getShapes(frame);\n    this._size = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.FrameLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  var __proto = FrameLayout.prototype;\n\n  __proto.layout = function (groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n\n      var outlines = this._layout(group.items, point, true);\n\n      group.outlines = outlines;\n      point = outlines.end;\n    }\n\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n\n  __proto._getItemSize = function () {\n    this._checkItemSize();\n\n    return this._itemSize;\n  };\n\n  __proto._checkItemSize = function () {\n    if (this.options.itemSize) {\n      this._itemSize = this.options.itemSize;\n      return;\n    }\n\n    var style = this._style;\n    var size = style.size2;\n    var margin = this.options.margin; // if itemSize is not in options, caculate itemSize from size.\n\n    this._itemSize = (this._size + margin) / this._shapes[size] - margin;\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    var _a;\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = items.length;\n    var style = this._style;\n    var _b = this.options,\n        margin = _b.margin,\n        frameFill = _b.frameFill;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var pos1Name = style.startPos1;\n    var pos2Name = style.startPos2;\n\n    var itemSize = this._getItemSize();\n\n    var isItemObject = typeof itemSize === \"object\";\n    var itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;\n    var itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;\n    var shapesSize = this._shapes[size2Name];\n    var shapes = this._shapes.shapes;\n    var shapesLength = shapes.length;\n    var startOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n    var endOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n    var dist = 0;\n    var end = 0;\n\n    if (!shapesLength) {\n      return {\n        start: outline,\n        end: outline\n      };\n    }\n\n    for (var i = 0; i < length; i += shapesLength) {\n      for (var j = 0; j < shapesLength && i + j < length; ++j) {\n        var item = items[i + j];\n        var shape = shapes[j];\n        var shapePos1 = shape[pos1Name];\n        var shapePos2 = shape[pos2Name];\n        var shapeSize1 = shape[size1Name];\n        var shapeSize2 = shape[size2Name];\n        var pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n        var pos2 = shapePos2 * (itemSize2 + margin);\n        var size1 = shapeSize1 * (itemSize1 + margin) - margin;\n        var size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n        for (var k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n          if (startOutline[k] === DUMMY_POSITION) {\n            startOutline[k] = pos1;\n          }\n\n          startOutline[k] = Math.min(startOutline[k], pos1);\n          endOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n        }\n\n        item.rect = (_a = {}, _a[pos1Name] = pos1, _a[pos2Name] = pos2, _a[size1Name] = size1, _a[size2Name] = size2, _a);\n      }\n\n      end = Math.max.apply(Math, endOutline); // check dist once\n\n      if (i !== 0) {\n        continue;\n      } // find & fill empty block\n\n\n      if (!frameFill) {\n        dist = 0;\n        continue;\n      }\n\n      dist = end;\n\n      for (var j = 0; j < shapesSize; ++j) {\n        if (startOutline[j] === DUMMY_POSITION) {\n          continue;\n        } // the dist between frame's end outline and next frame's start outline\n        // expect that next frame's start outline is startOutline[j] + end\n\n\n        dist = Math.min(startOutline[j] + end - endOutline[j], dist);\n      }\n    }\n\n    for (var i = 0; i < shapesSize; ++i) {\n      if (startOutline[i] !== DUMMY_POSITION) {\n        continue;\n      }\n\n      startOutline[i] = Math.max.apply(Math, startOutline);\n      endOutline[i] = startOutline[i];\n    } // The target outline is start outline when type is appending\n\n\n    var targetOutline = isAppend ? startOutline : endOutline;\n    var prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"].apply(Math, outline);\n    var prevOutlineDist = isAppend ? 0 : end;\n\n    if (frameFill && outline.length === shapesSize) {\n      prevOutlineDist = -DUMMY_POSITION;\n\n      for (var i = 0; i < shapesSize; ++i) {\n        if (startOutline[i] === endOutline[i]) {\n          continue;\n        } // if appending type is prepend(false), subtract dist from appending group's height.\n\n\n        prevOutlineDist = Math.min(targetOutline[i] + prevOutlineEnd - outline[i], prevOutlineDist);\n      }\n    }\n\n    for (var i = 0; i < shapesSize; ++i) {\n      startOutline[i] += prevOutlineEnd - prevOutlineDist;\n      endOutline[i] += prevOutlineEnd - prevOutlineDist;\n    }\n\n    items.forEach(function (item) {\n      item.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n    });\n    return {\n      start: startOutline.map(function (point) {\n        return parseInt(point, 10);\n      }),\n      end: endOutline.map(function (point) {\n        return parseInt(point, 10);\n      })\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    } // this only needs the size of the item.\n\n\n    var clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, isAppend)\n    };\n  };\n\n  return FrameLayout;\n}();\n\nfunction makeShapeOutline(outline, itemSize, columnLength, isAppend) {\n  var point = Math[isAppend ? \"min\" : \"max\"].apply(Math, outline) || 0;\n\n  if (outline.length !== columnLength) {\n    return fill(new Array(columnLength), 0);\n  }\n\n  return outline.map(function (l) {\n    return Math.floor((l - point) / itemSize);\n  });\n}\n\nfunction getColumn(item) {\n  if (item.column) {\n    return item.column;\n  }\n\n  var column = 1;\n\n  if (item.el) {\n    column = parseInt(item.el.getAttribute(\"data-column\"), 10) || 1;\n  }\n\n  item.column = column;\n  return column;\n}\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout         N   .    ,           .\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. (priority: `column` > `itemSize` > element's size)<ko>  .    0,      . (: `column` > `itemSize` >  ) </ko>\n * @param {Boolean} [options.column=0] The number of columns in the layout. If it is 0, the column is returned by `itemSize`.  (priority: `column` > `itemSize` > element's size)<ko>   .  column 0, `itemSize`  . (: `column` > `itemSize` >  ) </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n    horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n    margin: 10,\n    itemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n    margin: 10,\n    itemSize: 200,\n    horizontal: true,\n});\n\nvar item1 = '<div data-column=\"2\"></div>';\nvar item2 = \"<div></div>\"\nlayout.append([item1, item2]);\n</script>\n```\n **/\n\n\nvar SquareLayout = /*#__PURE__*/function (_super) {\n  __extends(SquareLayout, _super);\n\n  function SquareLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _super.call(this, options) || this;\n  }\n\n  var __proto = SquareLayout.prototype;\n\n  __proto._layout = function (items, outline, isAppend) {\n    var _a, _b;\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    if (isAppend === void 0) {\n      isAppend = false;\n    }\n\n    var itemSize = this._getSquareSize(items[0]);\n\n    var margin = this.options.margin;\n    var columnLength = this.options.column || Math.floor((this._size + margin) / (itemSize + margin)) || 1;\n    var length = items.length;\n    var endOutline = makeShapeOutline(outline, Math.floor(itemSize), columnLength, isAppend);\n    var pointCaculateName = isAppend ? \"min\" : \"max\";\n    var shapes = [];\n    var sign = isAppend ? 1 : -1;\n    var style = this._style;\n    var pos1Name = style.startPos1;\n    var pos2Name = style.startPos2;\n\n    for (var i = 0; i < length; ++i) {\n      var point = Math[pointCaculateName].apply(Math, endOutline);\n      var index = endOutline[isAppend ? \"indexOf\" : \"lastIndexOf\"](point);\n      var item = items[i];\n      var columnWidth = item.columnWidth;\n      var column = columnWidth && columnWidth[0] === columnLength && columnWidth[1] || getColumn(item);\n      var columnCount = 1;\n\n      if (column > 1) {\n        for (var j = 1; j < column && (isAppend && index + j < columnLength || !isAppend && index - j >= 0); ++j) {\n          if (isAppend && endOutline[index + sign * j] <= point || !isAppend && endOutline[index + sign * j] >= point) {\n            ++columnCount;\n            continue;\n          }\n\n          break;\n        }\n\n        if (!isAppend) {\n          index -= columnCount - 1;\n        }\n      }\n\n      item.columnWidth = [columnLength, columnCount];\n      shapes.push((_a = {\n        width: columnCount,\n        height: columnCount\n      }, _a[pos1Name] = point - (!isAppend ? columnCount : 0), _a[pos2Name] = index, _a.type = i + 1, _a.index = i, _a));\n\n      for (var j = 0; j < columnCount; ++j) {\n        endOutline[index + j] = point + sign * columnCount;\n      }\n    }\n\n    this._shapes = (_b = {\n      shapes: shapes\n    }, _b[style.size2] = columnLength, _b);\n\n    var result = _super.prototype._layout.call(this, items, outline, isAppend);\n\n    if (!isAppend) {\n      shapes.sort(function (shape1, shape2) {\n        var item1pos1 = shape1[pos1Name];\n        var item1pos2 = shape1[pos2Name];\n        var item2pos1 = shape2[pos1Name];\n        var item2pos2 = shape2[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n      items.sort(function (a, b) {\n        var item1pos1 = a.rect[pos1Name];\n        var item1pos2 = a.rect[pos2Name];\n        var item2pos1 = b.rect[pos1Name];\n        var item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    }\n\n    return result;\n  };\n\n  __proto._getSquareSize = function (item) {\n    var _a = this.options,\n        column = _a.column,\n        margin = _a.margin,\n        itemSize = _a.itemSize;\n\n    if (column) {\n      // if column is in options, caculate itemSize from column.\n      this._itemSize = (this._size + margin) / column - margin;\n    } else if (itemSize) {\n      this._itemSize = this.options.itemSize;\n    } else {\n      var sizeName = this._style.size2; // if frameSize is 0, caculate frameSize from item.size.\n\n      var frameSize = this._shapes[sizeName] || Math.floor((this._size + margin) / (item.size[sizeName] + margin) / getColumn(item));\n      this._itemSize = (this._size + margin) / frameSize - margin;\n    }\n\n    return this._itemSize;\n  };\n\n  return SquareLayout;\n}(FrameLayout);\n\nvar BoxModel = /*#__PURE__*/function () {\n  function BoxModel(options) {\n    assign(this, {\n      originWidth: 0,\n      originHeight: 0,\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0,\n      items: []\n    }, options);\n  }\n\n  var __proto = BoxModel.prototype;\n\n  __proto.scaleTo = function (width, height) {\n    var scaleX = this.width ? width / this.width : 0;\n    var scaleY = this.height ? height / this.height : 0;\n    this.items.forEach(function (v) {\n      if (scaleX !== 0) {\n        v.left *= scaleX;\n        v.width *= scaleX;\n      }\n\n      if (scaleY !== 0) {\n        v.top *= scaleY;\n        v.height *= scaleY;\n      }\n    });\n    this.width = width;\n    this.height = height;\n  };\n\n  __proto.push = function (item) {\n    this.items.push(item);\n  };\n\n  __proto.getOriginSize = function () {\n    return this.originWidth * this.originHeight;\n  };\n\n  __proto.getSize = function () {\n    return this.width * this.height;\n  };\n\n  __proto.getOriginRatio = function () {\n    return this.originHeight === 0 ? 0 : this.originWidth / this.originHeight;\n  };\n\n  __proto.getRatio = function () {\n    return this.height === 0 ? 0 : this.width / this.height;\n  };\n\n  return BoxModel;\n}();\n\nfunction getCost(originLength, length) {\n  var cost = originLength / length;\n\n  if (cost < 1) {\n    cost = 1 / cost;\n  }\n\n  return cost - 1;\n}\n\nfunction fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {\n  item.height = itemFitSize.height;\n  item.width = itemFitSize.width;\n  bestFitArea.height = containerFitSize.height;\n  bestFitArea.width = containerFitSize.width;\n\n  if (layoutVertical) {\n    item.top = bestFitArea.top + bestFitArea.height;\n    item.left = bestFitArea.left;\n  } else {\n    item.left = bestFitArea.left + bestFitArea.width;\n    item.top = bestFitArea.top;\n  }\n}\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout              .              .\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko>     </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko>      </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n  horizontal: true,\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n</script>\n```\n **/\n\n\nvar PackingLayout = /*#__PURE__*/function () {\n  function PackingLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      aspectRatio: 1,\n      sizeWeight: 1,\n      ratioWeight: 1\n    }, options);\n    this._size = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  var __proto = PackingLayout.prototype;\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.PackingLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  __proto.layout = function (groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n\n      var outlines = this._layout(group.items, point, true);\n\n      group.outlines = outlines;\n      point = outlines.end;\n    }\n\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n\n  __proto._findBestFitArea = function (container, item) {\n    if (container.getRatio() === 0) {\n      //     \n      container.originWidth = item.width;\n      container.originHeight = item.height;\n      container.width = item.width;\n      container.height = item.height;\n      return;\n    }\n\n    var bestFitArea;\n    var minCost = 10000000;\n    var layoutVertical = false;\n    var itemFitSize = {\n      width: 0,\n      height: 0\n    };\n    var containerFitSize = {\n      width: 0,\n      height: 0\n    };\n    var _a = this.options,\n        sizeWeight = _a.sizeWeight,\n        ratioWeight = _a.ratioWeight;\n    container.items.forEach(function (v) {\n      var containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n      var containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n      var width = v.width;\n      var height = v.height;\n      var cost;\n\n      for (var i = 0; i < 2; ++i) {\n        var itemWidth = void 0;\n        var itemHeight = void 0;\n        var containerWidth = void 0;\n        var containerHeight = void 0;\n\n        if (i === 0) {\n          //   \n          itemWidth = width;\n          itemHeight = height * (item.height / (v.originHeight + item.height));\n          containerWidth = width;\n          containerHeight = height - itemHeight;\n        } else {\n          //   \n          itemHeight = height;\n          itemWidth = width * (item.width / (v.originWidth + item.width));\n          containerHeight = height;\n          containerWidth = width - itemWidth;\n        }\n\n        var itemSize = itemWidth * itemHeight;\n        var itemRatio = itemWidth / itemHeight;\n        var containerSize = containerWidth * containerHeight;\n        var containerRatio = containerHeight / containerHeight;\n        cost = getCost(item.getSize(), itemSize) * sizeWeight;\n        cost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n        cost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n        cost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n        if (cost === Math.min(cost, minCost)) {\n          minCost = cost;\n          bestFitArea = v;\n          layoutVertical = i === 0;\n          itemFitSize.width = itemWidth;\n          itemFitSize.height = itemHeight;\n          containerFitSize.width = containerWidth;\n          containerFitSize.height = containerHeight;\n        }\n      }\n    });\n    fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    var _this = this;\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var style = this._style;\n    var _a = this.options,\n        horizontal = _a.horizontal,\n        aspectRatio = _a.aspectRatio,\n        margin = _a.margin;\n    var pos1Name = style.startPos1;\n    var containerWidth = this._size * (horizontal ? aspectRatio : 1);\n    var containerHeight = this._size / (horizontal ? 1 : aspectRatio);\n    var containerSize1 = horizontal ? containerWidth : containerHeight;\n    var prevOutline = toZeroArray(outline);\n    var start = isAppend ? Math.max.apply(Math, prevOutline) : Math.min.apply(Math, prevOutline) - containerSize1 - margin;\n    var end = start + containerSize1 + margin;\n    var container = new BoxModel({});\n    items.forEach(function (item) {\n      var _a = item.orgSize,\n          width = _a.width,\n          height = _a.height;\n      var model = new BoxModel({\n        width: width,\n        height: height,\n        originWidth: width,\n        originHeight: height\n      });\n\n      _this._findBestFitArea(container, model);\n\n      container.push(model);\n      container.scaleTo(containerWidth + margin, containerHeight + margin);\n    });\n    items.forEach(function (item, i) {\n      var boxItem = container.items[i];\n      var width = boxItem.width;\n      var height = boxItem.height;\n      var top = boxItem.top;\n      var left = boxItem.left;\n      item.rect = {\n        top: top,\n        left: left,\n        width: width - margin,\n        height: height - margin\n      };\n      item.rect[pos1Name] += start;\n    });\n    return {\n      start: [start],\n      end: [end]\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    } // this only needs the size of the item.\n\n\n    var clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, isAppend)\n    };\n  };\n\n  return PackingLayout;\n}();\n/* eslint-disable */\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\n\n\nfunction single_source_shortest_paths(graph, s, d) {\n  // Predecessor map for each node that has been encountered.\n  // node ID => predecessor node ID\n  var predecessors = {}; // Costs of shortest paths from s to all nodes encountered.\n  // node ID => cost\n\n  var costs = {};\n  costs[s] = 0; // Costs of shortest paths from s to all nodes encountered; differs from\n  // `costs` in that it provides easy access to the node that currently has\n  // the known shortest path from s.\n  // XXX: Do we actually need both `costs` and `open`?\n\n  var open = new BinaryHeap(function (x) {\n    return x.cost;\n  });\n  open.push({\n    value: s,\n    cost: 0\n  });\n  var closest;\n  var u;\n  var cost_of_s_to_u;\n  var adjacent_nodes;\n  var cost_of_e;\n  var cost_of_s_to_u_plus_cost_of_e;\n  var cost_of_s_to_v;\n  var first_visit;\n\n  while (open.size()) {\n    // In the nodes remaining in graph that have a known cost from s,\n    // find the node, u, that currently has the shortest path from s.\n    closest = open.pop();\n    u = closest.value;\n    cost_of_s_to_u = closest.cost; // Get nodes adjacent to u...\n\n    adjacent_nodes = graph(u) || {}; // ...and explore the edges that connect u to those nodes, updating\n    // the cost of the shortest paths to any or all of those nodes as\n    // necessary. v is the node across the current edge from u.\n\n    for (var v in adjacent_nodes) {\n      // Get the cost of the edge running from u to v.\n      cost_of_e = adjacent_nodes[v]; // Cost of s to u plus the cost of u to v across e--this is *a*\n      // cost from s to v that may or may not be less than the current\n      // known cost to v.\n\n      cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e; // If we haven't visited v yet OR if the current known cost from s to\n      // v is greater than the new cost we just found (cost of s to u plus\n      // cost of u to v across e), update v's cost in the cost list and\n      // update v's predecessor in the predecessor list (it's now u).\n\n      cost_of_s_to_v = costs[v];\n      first_visit = typeof costs[v] === \"undefined\";\n\n      if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n        costs[v] = cost_of_s_to_u_plus_cost_of_e;\n        open.push({\n          value: v,\n          cost: cost_of_s_to_u_plus_cost_of_e\n        });\n        predecessors[v] = u;\n      }\n    }\n  }\n\n  if (typeof costs[d] === \"undefined\") {\n    var msg = [\"Could not find a path from \", s, \" to \", d, \".\"].join(\"\");\n    throw new Error(msg);\n  }\n\n  return predecessors;\n}\n\nfunction extract_shortest_path_from_predecessor_list(predecessors, d) {\n  var nodes = [];\n  var u = d;\n\n  while (u) {\n    nodes.push(u);\n    u = predecessors[u];\n  }\n\n  nodes.reverse();\n  return nodes;\n}\n\nfunction find_path(graph, s, d) {\n  var predecessors = single_source_shortest_paths(graph, s, d);\n  return extract_shortest_path_from_predecessor_list(predecessors, d);\n}\n\nvar BinaryHeap = /*#__PURE__*/function () {\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  var __proto = BinaryHeap.prototype;\n\n  __proto.push = function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element); // Allow it to bubble up.\n\n    this.bubbleUp(this.content.length - 1);\n  };\n\n  __proto.pop = function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0]; // Get the element at the end of the array.\n\n    var end = this.content.pop(); // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n\n    return result;\n  };\n\n  __proto.size = function () {\n    return this.content.length;\n  };\n\n  __proto.bubbleUp = function (_n) {\n    var n = _n; // Fetch the element that has to be moved.\n\n    var element = this.content[n]; // When at 0, an element can not go up any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1;\n      var parent = this.content[parentN]; // Swap the elements if the parent is greater.\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent; // Update 'n' to continue at the new position.\n\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to move it further.\n        break;\n      }\n    }\n  };\n\n  __proto.sinkDown = function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n    var child1Score;\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2;\n      var child1N = child2N - 1; // This is used to store the new position of the element,\n      // if any.\n\n      var swap = null; // If the first child exists (is inside the array)...\n\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.\n\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      } // Do the same checks for the other child.\n\n\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n\n        if (child2Score < (swap == null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      } // If the element needs to be moved, swap it, and continue.\n\n\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } else {\n        // Otherwise, we are done.\n        break;\n      }\n    }\n  };\n\n  return BinaryHeap;\n}();\n/**\n * @classdesc 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko 'justified' '1    '    .           .\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko>     </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko>     </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko>      </ko>\n * @param {Array|Number} [options.row=0] The number or range of rows in a group, 0 is not set <ko>    , 0 </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n  column: 5,\n  horizontal: true,\n});\n\n</script>\n```\n **/\n\n\nvar JustifiedLayout = /*#__PURE__*/function () {\n  function JustifiedLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      minSize: 0,\n      maxSize: 0,\n      column: [1, 8],\n      row: 0\n    }, options);\n    this._style = getStyleNames(this.options.horizontal);\n    this._size = 0;\n  }\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  var __proto = JustifiedLayout.prototype;\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.JustifiedLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100]);\n   */\n\n\n  __proto.layout = function (groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n\n      var outlines = this._layout(group.items, point, true);\n\n      group.outlines = outlines;\n      point = outlines.end;\n    }\n\n    return this;\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    var row = this.options.row;\n    var path = [];\n\n    if (items.length) {\n      path = row ? this._getRowPath(items) : this._getPath(items);\n    }\n\n    return this._setStyle(items, path, outline, isAppend);\n  };\n\n  __proto._getPath = function (items) {\n    var _this = this;\n\n    var lastNode = items.length;\n    var column = this.options.column;\n\n    var _a = isObject(column) ? column : [column, column],\n        minColumn = _a[0],\n        maxColumn = _a[1];\n\n    var graph = function graph(nodeKey) {\n      var results = {};\n      var currentNode = parseInt(nodeKey, 10);\n\n      for (var nextNode = Math.min(currentNode + minColumn, lastNode); nextNode <= lastNode; ++nextNode) {\n        if (nextNode - currentNode > maxColumn) {\n          break;\n        }\n\n        var cost = _this._getCost(items, currentNode, nextNode);\n\n        if (cost < 0 && nextNode === lastNode) {\n          cost = 0;\n        }\n\n        results[\"\" + nextNode] = Math.pow(cost, 2);\n      }\n\n      return results;\n    }; // shortest path for items' total height.\n\n\n    return find_path(graph, \"0\", \"\" + lastNode);\n  };\n\n  __proto._getRowPath = function (items) {\n    var _a;\n\n    var column = this.options.column;\n    var row = this.options.row;\n    var columnRange = isObject(column) ? column : [column, column];\n    var rowRange = isObject(row) ? row : [row, row];\n\n    var pathLink = this._getRowLink(items, {\n      path: [0],\n      cost: 0,\n      length: 0,\n      currentNode: 0\n    }, columnRange, rowRange);\n\n    return (_a = pathLink === null || pathLink === void 0 ? void 0 : pathLink.path.map(function (node) {\n      return \"\" + node;\n    })) !== null && _a !== void 0 ? _a : [];\n  };\n\n  __proto._getRowLink = function (items, currentLink, columnRange, rowRange) {\n    var minColumn = columnRange[0];\n    var minRow = rowRange[0],\n        maxRow = rowRange[1];\n    var lastNode = items.length;\n    var path = currentLink.path,\n        pathLength = currentLink.length,\n        cost = currentLink.cost,\n        currentNode = currentLink.currentNode; // not reached lastNode but path is exceed or the number of remaining nodes is less than minColumn.\n\n    if (currentNode < lastNode && (maxRow <= pathLength || currentNode + minColumn > lastNode)) {\n      var rangeCost = getRangeCost(lastNode - currentNode, columnRange);\n      var lastCost = rangeCost * Math.abs(this._getCost(items, currentNode, lastNode));\n      return _assign(_assign({}, currentLink), {\n        length: pathLength + 1,\n        path: __spreadArrays(path, [lastNode]),\n        currentNode: lastNode,\n        cost: cost + lastCost,\n        isOver: true\n      });\n    } else if (currentNode >= lastNode) {\n      return _assign(_assign({}, currentLink), {\n        currentNode: lastNode,\n        isOver: minRow > pathLength || maxRow < pathLength\n      });\n    } else {\n      return this._searchRowLink(items, currentLink, lastNode, columnRange, rowRange);\n    }\n  };\n\n  __proto._searchRowLink = function (items, currentLink, lastNode, columnRange, rowRange) {\n    var minColumn = columnRange[0],\n        maxColumn = columnRange[1];\n    var currentNode = currentLink.currentNode,\n        path = currentLink.path,\n        pathLength = currentLink.length,\n        cost = currentLink.cost;\n    var length = Math.min(lastNode, currentNode + maxColumn);\n    var links = [];\n\n    for (var nextNode = currentNode + minColumn; nextNode <= length; ++nextNode) {\n      if (nextNode === currentNode) {\n        continue;\n      }\n\n      var nextCost = Math.abs(this._getCost(items, currentNode, nextNode));\n\n      var nextLink = this._getRowLink(items, {\n        path: __spreadArrays(path, [nextNode]),\n        length: pathLength + 1,\n        cost: cost + nextCost,\n        currentNode: nextNode\n      }, columnRange, rowRange);\n\n      if (nextLink) {\n        links.push(nextLink);\n      }\n    }\n\n    links.sort(function (a, b) {\n      var aIsOver = a.isOver;\n      var bIsOver = b.isOver;\n\n      if (aIsOver !== bIsOver) {\n        // If it is over, the cost is high.\n        return aIsOver ? 1 : -1;\n      }\n\n      var aRangeCost = getRangeCost(a.length, rowRange);\n      var bRangeCost = getRangeCost(b.length, rowRange);\n      return aRangeCost - bRangeCost || a.cost - b.cost;\n    }); // It returns the lowest cost link.\n\n    return links[0];\n  };\n\n  __proto._getSize = function (items, size1Name, size2Name) {\n    var margin = this.options.margin;\n    var size = items.reduce(function (sum, item) {\n      return sum + item.orgSize[size2Name] / item.orgSize[size1Name];\n    }, 0);\n    return (this._size - margin * (items.length - 1)) / size;\n  };\n\n  __proto._getCost = function (items, i, j) {\n    var style = this._style;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n\n    var size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\n    var min = this.options.minSize || 0;\n    var max = this.options.maxSize || Infinity;\n\n    if (isFinite(max)) {\n      // if this size is not in range, the cost increases sharply.\n      if (size < min) {\n        return Math.pow(size - min, 2) + Math.pow(max, 2);\n      } else if (size > max) {\n        return Math.pow(size - max, 2) + Math.pow(max, 2);\n      } else {\n        // if this size in range, the cost is negative or low.\n        return Math.min(size - max, min - size);\n      }\n    } // if max is infinite type, caculate cost only with \"min\".\n\n\n    if (size < min) {\n      return Math.max(Math.pow(min, 2), Math.pow(size, 2));\n    }\n\n    return size - min;\n  };\n\n  __proto._setStyle = function (items, path, outline, isAppend) {\n    var _a;\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var style = this._style; // if direction is vertical\n    // startPos1 : top, endPos1 : bottom\n    // size1 : height\n    // startPos2 : left, endPos2 : right\n    // size2 : width\n    // if direction is horizontal\n    // startPos1 : left, endPos1 : right\n    // size1 : width\n    // startPos2 : top, endPos2 : bottom\n    // size2 : height\n\n    var pos1Name = style.startPos1;\n    var size1Name = style.size1;\n    var pos2Name = style.startPos2;\n    var size2Name = style.size2;\n    var length = path.length;\n    var margin = this.options.margin;\n    var startPoint = outline[0] || 0;\n    var endPoint = startPoint;\n    var height = 0;\n\n    for (var i = 0; i < length - 1; ++i) {\n      var path1 = parseInt(path[i], 10);\n      var path2 = parseInt(path[i + 1], 10); // pathItems(path1 to path2) are in 1 line.\n\n      var pathItems = items.slice(path1, path2);\n      var pathItemsLength = pathItems.length;\n\n      var size1 = this._getSize(pathItems, size1Name, size2Name);\n\n      var pos1 = endPoint;\n\n      for (var j = 0; j < pathItemsLength; ++j) {\n        var item = pathItems[j];\n        var size2 = item.orgSize[size2Name] / item.orgSize[size1Name] * size1; // item has margin bottom and right.\n        // first item has not margin.\n\n        var prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n        var pos2 = prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0;\n        item.rect = (_a = {}, _a[pos1Name] = pos1, _a[pos2Name] = pos2, _a[size1Name] = size1, _a[size2Name] = size2, _a);\n      }\n\n      height += margin + size1;\n      endPoint = startPoint + height;\n    }\n\n    var itemsLength = items.length;\n\n    if (isAppend) {\n      // previous group's end outline is current group's start outline\n      return {\n        start: [startPoint],\n        end: [endPoint]\n      };\n    } // for prepend, only substract height from position.\n    // always start is lower than end.\n\n\n    for (var i = 0; i < itemsLength; ++i) {\n      var item = items[i]; // move items as long as height for prepend\n\n      item.rect[pos1Name] -= height;\n    }\n\n    return {\n      start: [startPoint - height],\n      end: [startPoint]\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    } // this only needs the size of the item.\n\n\n    var clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, isAppend)\n    };\n  };\n\n  return JustifiedLayout;\n}();\n/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\n\n\nexport default InfiniteGrid;\nexport { GridLayout, FrameLayout, SquareLayout, PackingLayout, JustifiedLayout, Infinite, DOMRenderer, ItemManager, CONTAINER_CLASSNAME, IGNORE_CLASSNAME, DEFAULT_OPTIONS, INFINITEGRID_METHODS, INFINITEGRID_EVENTS, categorize, withInfiniteGridMethods };"],"names":["_extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","win","_assign","assign","t","s","i","n","arguments","length","call","apply","_a","document","window","navigator","userAgent","ua","SUPPORT_COMPUTEDSTYLE","SUPPORT_ADDEVENTLISTENER","SUPPORT_PASSIVE","supportsPassiveOption","defineProperty","addEventListener","get","e","IS_IOS","test","IS_ANDROID2","CONTAINER_CLASSNAME","IGNORE_CLASSNAME","TRANSITION_NAME","DUMMY_POSITION","GROUPKEY_ATT","DEFAULT_OPTIONS","itemSelector","isOverflowScroll","threshold","isEqualSize","isConstantSize","useRecycle","horizontal","transitionDuration","useFit","attributePrefix","renderExternal","resizeDebounce","maxResizeDebounce","percentage","useOffset","DEFAULT_LAYOUT_OPTIONS","margin","agent","toLowerCase","ALIGN","webkit","exec","WEBKIT_VERSION","parseInt","DEFENSE_BROWSER","ITEM_KEYS","TRANSFORM","properties","transitionend","webkitTransitionEnd","MSTransitionEnd","oTransitionEnd","mozTransitionEnd","property","prefix","TRANSITION","TRANSITION_END","INFINITEGRID_EVENTS","INFINITEGRID_METHODS","getLoadingBar","getItem","getItems","layout","getGroupKeys","getStatus","setStatus","isProcessing","startLoading","endLoading","isLoading","updateItem","updateItems","moveTo","toArray","nodes","array","push","matchHTML","html","match","$","param","multi","el","dummy","createElement","innerHTML","childNodes","querySelectorAll","isWindow","jQuery","jquery","isJQuery","isArray","map","v","undefined","nodeName","nodeType","slice","addEvent","element","type","handler","eventListenerOptions","options","attachEvent","removeEvent","removeEventListener","detachEvent","getStyle","getComputedStyle","currentStyle","getSize","name","body","isDocument","doc","documentElement","Math","max","size","clientRect","getBoundingClientRect","right","left","bottom","top","cssSize","indexOf","parseFloat","getClientWidth","getClientHeight","getOffsetWidth","getOffsetHeight","getRectWidth","getRectHeight","getOffsetSize","width","height","getRectSize","STYLE","vertical","startPos1","endPos1","size1","startPos2","endPos2","size2","getStyleNames","isHorizontal","target","sources","_i","forEach","source","key","assignOptions","defaultOptions","cloneItems","items","item","fill","arr","value","isUndefined","categorize","newItems","newGroups","groupKeys","groupKey","group","withInfiniteGridMethods","infinitegridName","keys","args","result","addClass","className","classList","add","ItemManager","_groups","_groupKeys","__proto","toItems","elements","mounted","needUpdate","content","outerHTML","rect","makeItem","pluck","data","reduce","acc","concat","clear","startKey","endKey","datas","startIndex","endIndex","_data","item2","data2","status","_this","insertGroup","fit","base","groups","outlines","start","end","sliceGroups","getOutline","index","getEdgeIndex","cursor","prop","targetValue","Infinity","getEdgeValue","getGroup","clearOutlines","startCursor","endCursor","getGroups","getMaxEdgeValue","prependGroup","appendGroup","groupIndex","prevItems","newGroup","splice","insert","sync","removed","added","maintained","removedIndex","nextGroups","fromIndex","addedIndex","reverse","toIndex","syncItems","newItem","itemIndex","groupItem","groupItems","removeGroup","remove","indexesOfElement","getAttribute","getGroupByKey","itemKey","changed","nextItems","nextIndex","removeTransition","style","DOMRenderer","container","_size","view","viewport","_orgStyle","_isSizePercentage","_isPosPercentage","_init","resize","removeItems","removeElement","parentNode","removeChild","createElements","noElementItems","filter","replace","join","cssText","updateSize","orgSize","createAndInsert","isAppend","renderItems","_insert","renderItem","prevRect","setAttribute","position","_render","pos1","pos2","setTransition","itemRect","callback","getViewSize","getViewportSize","getContainerSize","setContainerSize","_calcSize","isResize","isNeededResize","destroy","overflowX","overflowY","selectContainer","querySelector","children","appendChild","createContainer","df","createDocumentFragment","insertBefore","firstChild","isSizePercentage","isPosPercentage","viewportSize","isHorizontalPercentage","isVerticalPercentage","Infinite","itemManger","append","prepend","recycle","_itemManager","setSize","_status","itemManager","prevVisisbleGroups","prevVisibleItems","startGroup","find","endGroup","findLast","nextStartCursor","nextEndCursor","minCursor","min","maxCursor","nextVisibleItems","visibleAdded","visibleRemoved","visibleChanged","scrollPos","isForward","endScrollPos","_b","visibles","isVisible","lastIndexOf","setCursor","scroll","getCursors","startEdgePos","endEdgePos","startPos","endPos","cache","cachedAppendData","cachedPrependData","isPrepend","getEdgeOutline","getVisibleItems","getCursor","getVisibleData","hasTarget","RenderManager","_infinite","_renderer","setLayout","_layout","render","callbackComponent","checkGroups","replaceTarget","removeTarget","im","check","on","_preReady","_error","hasLoading","isPreReadyOver","_readyElement","_ready","infinite","insertCursor","outlineCursor","prevGroup","outline","groupOutline","every","groupInfo","requestStartCursor","requestEndCursor","isInCursor","tempCursor","trigger","errorIndex","removeItem","src","HTMLImageElement","removeAttribute","replaceItem","totalIndex","removeTargetLength","replaceTargetLength","layoutedItems","Watcher","_resizeTimer","_maxResizeDebounceTimer","_containerOffset","_isScrollIssue","_prevPos","_onCheck","prevPos","getScrollPos","orgScrollPos","getOrgScrollPos","setScrollPos","_onResize","onResize","clearTimeout","setTimeout","_view","applyScrollPos","scrollTo","scrollBy","pos","x","y","arrPos","scrollLeft","scrollTop","getContainerOffset","reset","_getOffset","InfiniteGrid","_super","_loadingBar","_requestGroups","_reset","_watcher","_requestAppend","_requestPrepend","_recycle","_renderManager","LayoutKlass","_setSize","includeCached","getRenderingItems","itemKeys","nextVisisbleItems","beforeSync","isChange","_isProcessing","_postLayout","fromCache","isTrusted","firstGroup","hasChildren","isRelayout","renderer","visibleItems","isLayoutAll","_firstLayout","_relayout","_fit","_onLayoutComplete","isLayout","removeByIndex","syncElements","watcher","processingStatus","isReLayout","_appendLoadingBar","setLoadingBar","userLoadingBar","loadingBarObj","loadingSize","loadingStyle","loadingBar","isChangeLoadingBar","loadingElement","contains","RegExp","_renderLoading","_getLoadingStatus","userStyle","display","_process","next","_setContainerSize","_getEdgeValue","LOADING_APPEND","_fitItems","_updateItem","_scrollTo","_setScrollPos","_postCache","layoutGroups","isAdd","_getRandomKey","_insertItems","_c","ranges","isRecycle","some","posName","resetSize","_next","_setCursor","layoutItems","pop","shift","_d","_e","viewSize","isScroll","prevGroupKey_1","Date","getTime","floor","random","VERSION","START","CENTER","END","JUSTIFY","GridLayout","align","itemSize","_columnSize","_columnLength","_style","startOutline","firstItem","checkColumn","sizeName","columnSize","size1Name","size2Name","pos1Name","pos2Name","columnLength","viewDist","pointCaculateName","indexCaculateName","endOutline","point","column","sort","a","item1pos1","item1pos2","item2pos1","item2pos2","clone"],"sourceRoot":""}